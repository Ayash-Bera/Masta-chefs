"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@iden3";
exports.ids = ["vendor-chunks/@iden3"];
exports.modules = {

/***/ "(ssr)/./node_modules/@iden3/bigarray/src/bigarray.js":
/*!******************************************************!*\
  !*** ./node_modules/@iden3/bigarray/src/bigarray.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst SUBARRAY_SIZE = 0x40000;\n\nconst BigArrayHandler = {\n    get: function(obj, prop) {\n        if (!isNaN(prop)) {\n            return obj.getElement(prop);\n        } else return obj[prop];\n    },\n    set: function(obj, prop, value) {\n        if (!isNaN(prop)) {\n            return obj.setElement(prop, value);\n        } else {\n            obj[prop] = value;\n            return true;\n        }\n    }\n};\n\nclass _BigArray {\n    constructor (initSize) {\n        this.length = initSize || 0;\n        this.arr = new Array(SUBARRAY_SIZE);\n\n        for (let i=0; i<initSize; i+=SUBARRAY_SIZE) {\n            this.arr[i/SUBARRAY_SIZE] = new Array(Math.min(SUBARRAY_SIZE, initSize - i));\n        }\n        return this;\n    }\n    push () {\n        for (let i=0; i<arguments.length; i++) {\n            this.setElement (this.length, arguments[i]);\n        }\n    }\n\n    slice (f, t) {\n        const arr = new Array(t-f);\n        for (let i=f; i< t; i++) arr[i-f] = this.getElement(i);\n        return arr;\n    }\n    getElement(idx) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        const idx2 = idx % SUBARRAY_SIZE;\n        return this.arr[idx1] ? this.arr[idx1][idx2] : undefined;\n    }\n    setElement(idx, value) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        if (!this.arr[idx1]) {\n            this.arr[idx1] = new Array(SUBARRAY_SIZE);\n        }\n        const idx2 = idx % SUBARRAY_SIZE;\n        this.arr[idx1][idx2] = value;\n        if (idx >= this.length) this.length = idx+1;\n        return true;\n    }\n    getKeys() {\n        const newA = new BigArray();\n        for (let i=0; i<this.arr.length; i++) {\n            if (this.arr[i]) {\n                for (let j=0; j<this.arr[i].length; j++) {\n                    if (typeof this.arr[i][j] !== \"undefined\") {\n                        newA.push(i*SUBARRAY_SIZE+j);\n                    }\n                }\n            }\n        }\n        return newA;\n    }\n}\n\nclass BigArray {\n    constructor( initSize ) {\n        const obj = new _BigArray(initSize);\n        const extObj = new Proxy(obj, BigArrayHandler);\n        return extObj;\n    }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BigArray);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGlkZW4zL2JpZ2FycmF5L3NyYy9iaWdhcnJheS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBLDhCQUE4QixzQkFBc0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLFFBQVEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQGlkZW4zL2JpZ2FycmF5L3NyYy9iaWdhcnJheS5qcz9jZTBlIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNVQkFSUkFZX1NJWkUgPSAweDQwMDAwO1xuXG5jb25zdCBCaWdBcnJheUhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbihvYmosIHByb3ApIHtcbiAgICAgICAgaWYgKCFpc05hTihwcm9wKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5nZXRFbGVtZW50KHByb3ApO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIG9ialtwcm9wXTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24ob2JqLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzTmFOKHByb3ApKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLnNldEVsZW1lbnQocHJvcCwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmNsYXNzIF9CaWdBcnJheSB7XG4gICAgY29uc3RydWN0b3IgKGluaXRTaXplKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gaW5pdFNpemUgfHwgMDtcbiAgICAgICAgdGhpcy5hcnIgPSBuZXcgQXJyYXkoU1VCQVJSQVlfU0laRSk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGluaXRTaXplOyBpKz1TVUJBUlJBWV9TSVpFKSB7XG4gICAgICAgICAgICB0aGlzLmFycltpL1NVQkFSUkFZX1NJWkVdID0gbmV3IEFycmF5KE1hdGgubWluKFNVQkFSUkFZX1NJWkUsIGluaXRTaXplIC0gaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBwdXNoICgpIHtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50ICh0aGlzLmxlbmd0aCwgYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNsaWNlIChmLCB0KSB7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheSh0LWYpO1xuICAgICAgICBmb3IgKGxldCBpPWY7IGk8IHQ7IGkrKykgYXJyW2ktZl0gPSB0aGlzLmdldEVsZW1lbnQoaSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIGdldEVsZW1lbnQoaWR4KSB7XG4gICAgICAgIGlkeCA9IHBhcnNlSW50KGlkeCk7XG4gICAgICAgIGNvbnN0IGlkeDEgPSBNYXRoLmZsb29yKGlkeCAvIFNVQkFSUkFZX1NJWkUpO1xuICAgICAgICBjb25zdCBpZHgyID0gaWR4ICUgU1VCQVJSQVlfU0laRTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyW2lkeDFdID8gdGhpcy5hcnJbaWR4MV1baWR4Ml0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHNldEVsZW1lbnQoaWR4LCB2YWx1ZSkge1xuICAgICAgICBpZHggPSBwYXJzZUludChpZHgpO1xuICAgICAgICBjb25zdCBpZHgxID0gTWF0aC5mbG9vcihpZHggLyBTVUJBUlJBWV9TSVpFKTtcbiAgICAgICAgaWYgKCF0aGlzLmFycltpZHgxXSkge1xuICAgICAgICAgICAgdGhpcy5hcnJbaWR4MV0gPSBuZXcgQXJyYXkoU1VCQVJSQVlfU0laRSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWR4MiA9IGlkeCAlIFNVQkFSUkFZX1NJWkU7XG4gICAgICAgIHRoaXMuYXJyW2lkeDFdW2lkeDJdID0gdmFsdWU7XG4gICAgICAgIGlmIChpZHggPj0gdGhpcy5sZW5ndGgpIHRoaXMubGVuZ3RoID0gaWR4KzE7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXRLZXlzKCkge1xuICAgICAgICBjb25zdCBuZXdBID0gbmV3IEJpZ0FycmF5KCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLmFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXJyW2ldKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPHRoaXMuYXJyW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5hcnJbaV1bal0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0EucHVzaChpKlNVQkFSUkFZX1NJWkUraik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0E7XG4gICAgfVxufVxuXG5jbGFzcyBCaWdBcnJheSB7XG4gICAgY29uc3RydWN0b3IoIGluaXRTaXplICkge1xuICAgICAgICBjb25zdCBvYmogPSBuZXcgX0JpZ0FycmF5KGluaXRTaXplKTtcbiAgICAgICAgY29uc3QgZXh0T2JqID0gbmV3IFByb3h5KG9iaiwgQmlnQXJyYXlIYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIGV4dE9iajtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJpZ0FycmF5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@iden3/bigarray/src/bigarray.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js":
/*!**************************************************************!*\
  !*** ./node_modules/@iden3/binfileutils/src/binfileutils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   copySection: () => (/* binding */ copySection),\n/* harmony export */   createBinFile: () => (/* binding */ createBinFile),\n/* harmony export */   endReadSection: () => (/* binding */ endReadSection),\n/* harmony export */   endWriteSection: () => (/* binding */ endWriteSection),\n/* harmony export */   readBigInt: () => (/* binding */ readBigInt),\n/* harmony export */   readBinFile: () => (/* binding */ readBinFile),\n/* harmony export */   readSection: () => (/* binding */ readSection),\n/* harmony export */   sectionIsEqual: () => (/* binding */ sectionIsEqual),\n/* harmony export */   startReadUniqueSection: () => (/* binding */ startReadUniqueSection),\n/* harmony export */   startWriteSection: () => (/* binding */ startWriteSection),\n/* harmony export */   writeBigInt: () => (/* binding */ writeBigInt)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/ffjavascript/main.js\");\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fastfile */ \"(ssr)/./node_modules/fastfile/src/fastfile.js\");\n\n\n\n\nasync function readBinFile(fileName, type, maxVersion, cacheSize, pageSize) {\n\n    const fd = await fastfile__WEBPACK_IMPORTED_MODULE_1__.readExisting(fileName, cacheSize, pageSize);\n\n    const b = await fd.read(4);\n    let readedType = \"\";\n    for (let i=0; i<4; i++) readedType += String.fromCharCode(b[i]);\n\n    if (readedType != type) throw new Error(fileName + \": Invalid File format\");\n\n    let v = await fd.readULE32();\n\n    if (v>maxVersion) throw new Error(\"Version not supported\");\n\n    const nSections = await fd.readULE32();\n\n    // Scan sections\n    let sections = [];\n    for (let i=0; i<nSections; i++) {\n        let ht = await fd.readULE32();\n        let hl = await fd.readULE64();\n        if (typeof sections[ht] == \"undefined\") sections[ht] = [];\n        sections[ht].push({\n            p: fd.pos,\n            size: hl\n        });\n        fd.pos += hl;\n    }\n\n    return {fd, sections};\n}\n\nasync function createBinFile(fileName, type, version, nSections, cacheSize, pageSize) {\n\n    const fd = await fastfile__WEBPACK_IMPORTED_MODULE_1__.createOverride(fileName, cacheSize, pageSize);\n\n    const buff = new Uint8Array(4);\n    for (let i=0; i<4; i++) buff[i] = type.charCodeAt(i);\n    await fd.write(buff, 0); // Magic \"r1cs\"\n\n    await fd.writeULE32(version); // Version\n    await fd.writeULE32(nSections); // Number of Sections\n\n    return fd;\n}\n\nasync function startWriteSection(fd, idSection) {\n    if (typeof fd.writingSection !== \"undefined\") throw new Error(\"Already writing a section\");\n    await fd.writeULE32(idSection); // Header type\n    fd.writingSection = {\n        pSectionSize: fd.pos\n    };\n    await fd.writeULE64(0); // Temporally set to 0 length\n}\n\nasync function endWriteSection(fd) {\n    if (typeof fd.writingSection === \"undefined\") throw new Error(\"Not writing a section\");\n\n    const sectionSize = fd.pos - fd.writingSection.pSectionSize - 8;\n    const oldPos = fd.pos;\n    fd.pos = fd.writingSection.pSectionSize;\n    await fd.writeULE64(sectionSize);\n    fd.pos = oldPos;\n    delete fd.writingSection;\n}\n\nasync function startReadUniqueSection(fd, sections, idSection) {\n    if (typeof fd.readingSection !== \"undefined\") throw new Error(\"Already reading a section\");\n    if (!sections[idSection])  throw new Error(fd.fileName + \": Missing section \"+ idSection );\n    if (sections[idSection].length>1) throw new Error(fd.fileName +\": Section Duplicated \" +idSection);\n\n    fd.pos = sections[idSection][0].p;\n\n    fd.readingSection = sections[idSection][0];\n}\n\nasync function endReadSection(fd, noCheck) {\n    if (typeof fd.readingSection === \"undefined\") throw new Error(\"Not reading a section\");\n    if (!noCheck) {\n        if (fd.pos-fd.readingSection.p !=  fd.readingSection.size) throw new Error(\"Invalid section size reading\");\n    }\n    delete fd.readingSection;\n}\n\nasync function writeBigInt(fd, n, n8, pos) {\n    const buff = new Uint8Array(n8);\n    ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toRprLE(buff, 0, n, n8);\n    await fd.write(buff, pos);\n}\n\nasync function readBigInt(fd, n8, pos) {\n    const buff = await fd.read(n8, pos);\n    return ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromRprLE(buff, 0, n8);\n}\n\nasync function copySection(fdFrom, sections, fdTo, sectionId, size) {\n    if (typeof size === \"undefined\") {\n        size = sections[sectionId][0].size;\n    }\n    const chunkSize = fdFrom.pageSize;\n    await startReadUniqueSection(fdFrom, sections, sectionId);\n    await startWriteSection(fdTo, sectionId);\n    for (let p=0; p<size; p+=chunkSize) {\n        const l = Math.min(size -p, chunkSize);\n        const buff = await fdFrom.read(l);\n        await fdTo.write(buff);\n    }\n    await endWriteSection(fdTo);\n    await endReadSection(fdFrom, size != sections[sectionId][0].size);\n\n}\n\nasync function readSection(fd, sections, idSection, offset, length) {\n\n    offset = (typeof offset === \"undefined\") ? 0 : offset;\n    length = (typeof length === \"undefined\") ? sections[idSection][0].size - offset : length;\n\n    if (offset + length > sections[idSection][0].size) {\n        throw new Error(\"Reading out of the range of the section\");\n    }\n\n    let buff;\n    if (length < (1 << 30) ) {\n        buff = new Uint8Array(length);\n    } else {\n        buff = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(length);\n    }\n\n    await fd.readToBuffer(buff, 0, length, sections[idSection][0].p + offset);\n    return buff;\n}\n\nasync function sectionIsEqual(fd1, sections1, fd2, sections2, idSection) {\n    const MAX_BUFF_SIZE = fd1.pageSize * 16;\n    await startReadUniqueSection(fd1, sections1, idSection);\n    await startReadUniqueSection(fd2, sections2, idSection);\n    if (sections1[idSection][0].size != sections2[idSection][0].size) return false;\n    const totalBytes=sections1[idSection][0].size;\n    for (let i=0; i<totalBytes; i+= MAX_BUFF_SIZE) {\n        const n = Math.min(totalBytes-i, MAX_BUFF_SIZE);\n        const buff1 = await fd1.read(n);\n        const buff2 = await fd2.read(n);\n        for (let j=0; j<n; j++) if (buff1[j] != buff2[j]) return false;\n    }\n    await endReadSection(fd1);\n    await endReadSection(fd2);\n    return true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGlkZW4zL2JpbmZpbGV1dGlscy9zcmMvYmluZmlsZXV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ2tEO0FBQ2I7O0FBRTlCOztBQUVQLHFCQUFxQixrREFBcUI7O0FBRTFDO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSzs7QUFFdkI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFTzs7QUFFUCxxQkFBcUIsb0RBQXVCOztBQUU1QztBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCLDZCQUE2Qjs7QUFFN0Isa0NBQWtDO0FBQ2xDLG9DQUFvQzs7QUFFcEM7QUFDQTs7QUFFTztBQUNQO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLElBQUksZ0RBQU07QUFDVjtBQUNBOztBQUVPO0FBQ1A7QUFDQSxXQUFXLGdEQUFNO0FBQ2pCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixtQkFBbUIsbURBQVM7QUFDNUI7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0BpZGVuMy9iaW5maWxldXRpbHMvc3JjL2JpbmZpbGV1dGlscy5qcz8wZmQ1Il0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0ICB7IFNjYWxhciwgQmlnQnVmZmVyIH0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuaW1wb3J0ICogYXMgZmFzdEZpbGUgZnJvbSBcImZhc3RmaWxlXCI7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkQmluRmlsZShmaWxlTmFtZSwgdHlwZSwgbWF4VmVyc2lvbiwgY2FjaGVTaXplLCBwYWdlU2l6ZSkge1xuXG4gICAgY29uc3QgZmQgPSBhd2FpdCBmYXN0RmlsZS5yZWFkRXhpc3RpbmcoZmlsZU5hbWUsIGNhY2hlU2l6ZSwgcGFnZVNpemUpO1xuXG4gICAgY29uc3QgYiA9IGF3YWl0IGZkLnJlYWQoNCk7XG4gICAgbGV0IHJlYWRlZFR5cGUgPSBcIlwiO1xuICAgIGZvciAobGV0IGk9MDsgaTw0OyBpKyspIHJlYWRlZFR5cGUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiW2ldKTtcblxuICAgIGlmIChyZWFkZWRUeXBlICE9IHR5cGUpIHRocm93IG5ldyBFcnJvcihmaWxlTmFtZSArIFwiOiBJbnZhbGlkIEZpbGUgZm9ybWF0XCIpO1xuXG4gICAgbGV0IHYgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcblxuICAgIGlmICh2Pm1heFZlcnNpb24pIHRocm93IG5ldyBFcnJvcihcIlZlcnNpb24gbm90IHN1cHBvcnRlZFwiKTtcblxuICAgIGNvbnN0IG5TZWN0aW9ucyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuXG4gICAgLy8gU2NhbiBzZWN0aW9uc1xuICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTxuU2VjdGlvbnM7IGkrKykge1xuICAgICAgICBsZXQgaHQgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICAgICAgbGV0IGhsID0gYXdhaXQgZmQucmVhZFVMRTY0KCk7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VjdGlvbnNbaHRdID09IFwidW5kZWZpbmVkXCIpIHNlY3Rpb25zW2h0XSA9IFtdO1xuICAgICAgICBzZWN0aW9uc1todF0ucHVzaCh7XG4gICAgICAgICAgICBwOiBmZC5wb3MsXG4gICAgICAgICAgICBzaXplOiBobFxuICAgICAgICB9KTtcbiAgICAgICAgZmQucG9zICs9IGhsO1xuICAgIH1cblxuICAgIHJldHVybiB7ZmQsIHNlY3Rpb25zfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUJpbkZpbGUoZmlsZU5hbWUsIHR5cGUsIHZlcnNpb24sIG5TZWN0aW9ucywgY2FjaGVTaXplLCBwYWdlU2l6ZSkge1xuXG4gICAgY29uc3QgZmQgPSBhd2FpdCBmYXN0RmlsZS5jcmVhdGVPdmVycmlkZShmaWxlTmFtZSwgY2FjaGVTaXplLCBwYWdlU2l6ZSk7XG5cbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPDQ7IGkrKykgYnVmZltpXSA9IHR5cGUuY2hhckNvZGVBdChpKTtcbiAgICBhd2FpdCBmZC53cml0ZShidWZmLCAwKTsgLy8gTWFnaWMgXCJyMWNzXCJcblxuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIodmVyc2lvbik7IC8vIFZlcnNpb25cbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKG5TZWN0aW9ucyk7IC8vIE51bWJlciBvZiBTZWN0aW9uc1xuXG4gICAgcmV0dXJuIGZkO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RhcnRXcml0ZVNlY3Rpb24oZmQsIGlkU2VjdGlvbikge1xuICAgIGlmICh0eXBlb2YgZmQud3JpdGluZ1NlY3Rpb24gIT09IFwidW5kZWZpbmVkXCIpIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgd3JpdGluZyBhIHNlY3Rpb25cIik7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihpZFNlY3Rpb24pOyAvLyBIZWFkZXIgdHlwZVxuICAgIGZkLndyaXRpbmdTZWN0aW9uID0ge1xuICAgICAgICBwU2VjdGlvblNpemU6IGZkLnBvc1xuICAgIH07XG4gICAgYXdhaXQgZmQud3JpdGVVTEU2NCgwKTsgLy8gVGVtcG9yYWxseSBzZXQgdG8gMCBsZW5ndGhcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuZFdyaXRlU2VjdGlvbihmZCkge1xuICAgIGlmICh0eXBlb2YgZmQud3JpdGluZ1NlY3Rpb24gPT09IFwidW5kZWZpbmVkXCIpIHRocm93IG5ldyBFcnJvcihcIk5vdCB3cml0aW5nIGEgc2VjdGlvblwiKTtcblxuICAgIGNvbnN0IHNlY3Rpb25TaXplID0gZmQucG9zIC0gZmQud3JpdGluZ1NlY3Rpb24ucFNlY3Rpb25TaXplIC0gODtcbiAgICBjb25zdCBvbGRQb3MgPSBmZC5wb3M7XG4gICAgZmQucG9zID0gZmQud3JpdGluZ1NlY3Rpb24ucFNlY3Rpb25TaXplO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFNjQoc2VjdGlvblNpemUpO1xuICAgIGZkLnBvcyA9IG9sZFBvcztcbiAgICBkZWxldGUgZmQud3JpdGluZ1NlY3Rpb247XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgaWRTZWN0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBmZC5yZWFkaW5nU2VjdGlvbiAhPT0gXCJ1bmRlZmluZWRcIikgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSByZWFkaW5nIGEgc2VjdGlvblwiKTtcbiAgICBpZiAoIXNlY3Rpb25zW2lkU2VjdGlvbl0pICB0aHJvdyBuZXcgRXJyb3IoZmQuZmlsZU5hbWUgKyBcIjogTWlzc2luZyBzZWN0aW9uIFwiKyBpZFNlY3Rpb24gKTtcbiAgICBpZiAoc2VjdGlvbnNbaWRTZWN0aW9uXS5sZW5ndGg+MSkgdGhyb3cgbmV3IEVycm9yKGZkLmZpbGVOYW1lICtcIjogU2VjdGlvbiBEdXBsaWNhdGVkIFwiICtpZFNlY3Rpb24pO1xuXG4gICAgZmQucG9zID0gc2VjdGlvbnNbaWRTZWN0aW9uXVswXS5wO1xuXG4gICAgZmQucmVhZGluZ1NlY3Rpb24gPSBzZWN0aW9uc1tpZFNlY3Rpb25dWzBdO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5kUmVhZFNlY3Rpb24oZmQsIG5vQ2hlY2spIHtcbiAgICBpZiAodHlwZW9mIGZkLnJlYWRpbmdTZWN0aW9uID09PSBcInVuZGVmaW5lZFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgcmVhZGluZyBhIHNlY3Rpb25cIik7XG4gICAgaWYgKCFub0NoZWNrKSB7XG4gICAgICAgIGlmIChmZC5wb3MtZmQucmVhZGluZ1NlY3Rpb24ucCAhPSAgZmQucmVhZGluZ1NlY3Rpb24uc2l6ZSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWN0aW9uIHNpemUgcmVhZGluZ1wiKTtcbiAgICB9XG4gICAgZGVsZXRlIGZkLnJlYWRpbmdTZWN0aW9uO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd3JpdGVCaWdJbnQoZmQsIG4sIG44LCBwb3MpIHtcbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkobjgpO1xuICAgIFNjYWxhci50b1JwckxFKGJ1ZmYsIDAsIG4sIG44KTtcbiAgICBhd2FpdCBmZC53cml0ZShidWZmLCBwb3MpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZEJpZ0ludChmZCwgbjgsIHBvcykge1xuICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZC5yZWFkKG44LCBwb3MpO1xuICAgIHJldHVybiBTY2FsYXIuZnJvbVJwckxFKGJ1ZmYsIDAsIG44KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvcHlTZWN0aW9uKGZkRnJvbSwgc2VjdGlvbnMsIGZkVG8sIHNlY3Rpb25JZCwgc2l6ZSkge1xuICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBzaXplID0gc2VjdGlvbnNbc2VjdGlvbklkXVswXS5zaXplO1xuICAgIH1cbiAgICBjb25zdCBjaHVua1NpemUgPSBmZEZyb20ucGFnZVNpemU7XG4gICAgYXdhaXQgc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZEZyb20sIHNlY3Rpb25zLCBzZWN0aW9uSWQpO1xuICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkVG8sIHNlY3Rpb25JZCk7XG4gICAgZm9yIChsZXQgcD0wOyBwPHNpemU7IHArPWNodW5rU2l6ZSkge1xuICAgICAgICBjb25zdCBsID0gTWF0aC5taW4oc2l6ZSAtcCwgY2h1bmtTaXplKTtcbiAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkRnJvbS5yZWFkKGwpO1xuICAgICAgICBhd2FpdCBmZFRvLndyaXRlKGJ1ZmYpO1xuICAgIH1cbiAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRUbyk7XG4gICAgYXdhaXQgZW5kUmVhZFNlY3Rpb24oZmRGcm9tLCBzaXplICE9IHNlY3Rpb25zW3NlY3Rpb25JZF1bMF0uc2l6ZSk7XG5cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWRTZWN0aW9uKGZkLCBzZWN0aW9ucywgaWRTZWN0aW9uLCBvZmZzZXQsIGxlbmd0aCkge1xuXG4gICAgb2Zmc2V0ID0gKHR5cGVvZiBvZmZzZXQgPT09IFwidW5kZWZpbmVkXCIpID8gMCA6IG9mZnNldDtcbiAgICBsZW5ndGggPSAodHlwZW9mIGxlbmd0aCA9PT0gXCJ1bmRlZmluZWRcIikgPyBzZWN0aW9uc1tpZFNlY3Rpb25dWzBdLnNpemUgLSBvZmZzZXQgOiBsZW5ndGg7XG5cbiAgICBpZiAob2Zmc2V0ICsgbGVuZ3RoID4gc2VjdGlvbnNbaWRTZWN0aW9uXVswXS5zaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWRpbmcgb3V0IG9mIHRoZSByYW5nZSBvZiB0aGUgc2VjdGlvblwiKTtcbiAgICB9XG5cbiAgICBsZXQgYnVmZjtcbiAgICBpZiAobGVuZ3RoIDwgKDEgPDwgMzApICkge1xuICAgICAgICBidWZmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBidWZmID0gbmV3IEJpZ0J1ZmZlcihsZW5ndGgpO1xuICAgIH1cblxuICAgIGF3YWl0IGZkLnJlYWRUb0J1ZmZlcihidWZmLCAwLCBsZW5ndGgsIHNlY3Rpb25zW2lkU2VjdGlvbl1bMF0ucCArIG9mZnNldCk7XG4gICAgcmV0dXJuIGJ1ZmY7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZWN0aW9uSXNFcXVhbChmZDEsIHNlY3Rpb25zMSwgZmQyLCBzZWN0aW9uczIsIGlkU2VjdGlvbikge1xuICAgIGNvbnN0IE1BWF9CVUZGX1NJWkUgPSBmZDEucGFnZVNpemUgKiAxNjtcbiAgICBhd2FpdCBzdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkMSwgc2VjdGlvbnMxLCBpZFNlY3Rpb24pO1xuICAgIGF3YWl0IHN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQyLCBzZWN0aW9uczIsIGlkU2VjdGlvbik7XG4gICAgaWYgKHNlY3Rpb25zMVtpZFNlY3Rpb25dWzBdLnNpemUgIT0gc2VjdGlvbnMyW2lkU2VjdGlvbl1bMF0uc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHRvdGFsQnl0ZXM9c2VjdGlvbnMxW2lkU2VjdGlvbl1bMF0uc2l6ZTtcbiAgICBmb3IgKGxldCBpPTA7IGk8dG90YWxCeXRlczsgaSs9IE1BWF9CVUZGX1NJWkUpIHtcbiAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKHRvdGFsQnl0ZXMtaSwgTUFYX0JVRkZfU0laRSk7XG4gICAgICAgIGNvbnN0IGJ1ZmYxID0gYXdhaXQgZmQxLnJlYWQobik7XG4gICAgICAgIGNvbnN0IGJ1ZmYyID0gYXdhaXQgZmQyLnJlYWQobik7XG4gICAgICAgIGZvciAobGV0IGo9MDsgajxuOyBqKyspIGlmIChidWZmMVtqXSAhPSBidWZmMltqXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhd2FpdCBlbmRSZWFkU2VjdGlvbihmZDEpO1xuICAgIGF3YWl0IGVuZFJlYWRTZWN0aW9uKGZkMik7XG4gICAgcmV0dXJuIHRydWU7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@iden3/binfileutils/src/binfileutils.js\n");

/***/ })

};
;