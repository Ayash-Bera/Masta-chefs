"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/circom_runtime";
exports.ids = ["vendor-chunks/circom_runtime"];
exports.modules = {

/***/ "(ssr)/./node_modules/circom_runtime/js/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/circom_runtime/js/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   flatArray: () => (/* binding */ flatArray),\n/* harmony export */   fnvHash: () => (/* binding */ fnvHash),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   toArray32: () => (/* binding */ toArray32)\n/* harmony export */ });\n/*\n\nCopyright 2020 0KIMS association.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nfunction flatArray(a) {\n    let res = [];\n    fillArray(res, a);\n    return res;\n\n    function fillArray(res, a) {\n        if (Array.isArray(a)) {\n            for (let i = 0; i < a.length; i++) {\n                fillArray(res, a[i]);\n            }\n        } else {\n            res.push(a);\n        }\n    }\n}\n\n// Ref https://github.com/iden3/circom/commit/ec6388cf6eb62463539cb4c40cc3ceae9826de19\nfunction normalize(n, prime) {\n    let res = BigInt(n) % prime;\n    if (res < 0) res += prime;\n    return res;\n}\n\nfunction fnvHash(str) {\n    const uint64_max = BigInt(2) ** BigInt(64);\n    let hash = BigInt(\"0xCBF29CE484222325\");\n    for (let i = 0; i < str.length; i++) {\n        hash ^= BigInt(str[i].charCodeAt(0));\n        hash *= BigInt(0x100000001B3);\n        hash %= uint64_max;\n    }\n    let shash = hash.toString(16);\n    let n = 16 - shash.length;\n    shash = \"0\".repeat(n).concat(shash);\n    return shash;\n}\n\n// Note that this pads zeros\nfunction toArray32(s, size) {\n    const res = []; //new Uint32Array(size); //has no unshift\n    let rem = BigInt(s);\n    const radix = BigInt(0x100000000);\n    while (rem) {\n        res.unshift(Number(rem % radix));\n        rem = rem / radix;\n    }\n    if (size) {\n        let i = size - res.length;\n        while (i > 0) {\n            res.unshift(0);\n            i--;\n        }\n    }\n    return res;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2lyY29tX3J1bnRpbWUvanMvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1Asb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL2NpcmNvbV9ydW50aW1lL2pzL3V0aWxzLmpzPzJiYzkiXSwic291cmNlc0NvbnRlbnQiOlsiLypcblxuQ29weXJpZ2h0IDIwMjAgMEtJTVMgYXNzb2NpYXRpb24uXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5leHBvcnQgZnVuY3Rpb24gZmxhdEFycmF5KGEpIHtcbiAgICBsZXQgcmVzID0gW107XG4gICAgZmlsbEFycmF5KHJlcywgYSk7XG4gICAgcmV0dXJuIHJlcztcblxuICAgIGZ1bmN0aW9uIGZpbGxBcnJheShyZXMsIGEpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZpbGxBcnJheShyZXMsIGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzLnB1c2goYSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIFJlZiBodHRwczovL2dpdGh1Yi5jb20vaWRlbjMvY2lyY29tL2NvbW1pdC9lYzYzODhjZjZlYjYyNDYzNTM5Y2I0YzQwY2MzY2VhZTk4MjZkZTE5XG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKG4sIHByaW1lKSB7XG4gICAgbGV0IHJlcyA9IEJpZ0ludChuKSAlIHByaW1lO1xuICAgIGlmIChyZXMgPCAwKSByZXMgKz0gcHJpbWU7XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZudkhhc2goc3RyKSB7XG4gICAgY29uc3QgdWludDY0X21heCA9IEJpZ0ludCgyKSAqKiBCaWdJbnQoNjQpO1xuICAgIGxldCBoYXNoID0gQmlnSW50KFwiMHhDQkYyOUNFNDg0MjIyMzI1XCIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhhc2ggXj0gQmlnSW50KHN0cltpXS5jaGFyQ29kZUF0KDApKTtcbiAgICAgICAgaGFzaCAqPSBCaWdJbnQoMHgxMDAwMDAwMDFCMyk7XG4gICAgICAgIGhhc2ggJT0gdWludDY0X21heDtcbiAgICB9XG4gICAgbGV0IHNoYXNoID0gaGFzaC50b1N0cmluZygxNik7XG4gICAgbGV0IG4gPSAxNiAtIHNoYXNoLmxlbmd0aDtcbiAgICBzaGFzaCA9IFwiMFwiLnJlcGVhdChuKS5jb25jYXQoc2hhc2gpO1xuICAgIHJldHVybiBzaGFzaDtcbn1cblxuLy8gTm90ZSB0aGF0IHRoaXMgcGFkcyB6ZXJvc1xuZXhwb3J0IGZ1bmN0aW9uIHRvQXJyYXkzMihzLCBzaXplKSB7XG4gICAgY29uc3QgcmVzID0gW107IC8vbmV3IFVpbnQzMkFycmF5KHNpemUpOyAvL2hhcyBubyB1bnNoaWZ0XG4gICAgbGV0IHJlbSA9IEJpZ0ludChzKTtcbiAgICBjb25zdCByYWRpeCA9IEJpZ0ludCgweDEwMDAwMDAwMCk7XG4gICAgd2hpbGUgKHJlbSkge1xuICAgICAgICByZXMudW5zaGlmdChOdW1iZXIocmVtICUgcmFkaXgpKTtcbiAgICAgICAgcmVtID0gcmVtIC8gcmFkaXg7XG4gICAgfVxuICAgIGlmIChzaXplKSB7XG4gICAgICAgIGxldCBpID0gc2l6ZSAtIHJlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpID4gMCkge1xuICAgICAgICAgICAgcmVzLnVuc2hpZnQoMCk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/circom_runtime/js/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/circom_runtime/js/witness_calculator.js":
/*!**************************************************************!*\
  !*** ./node_modules/circom_runtime/js/witness_calculator.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ builder)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/circom_runtime/js/utils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/./node_modules/ffjavascript/main.js\");\n/* globals WebAssembly */\n/*\n\nCopyright 2020 0KIMS association.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n\n\n\nasync function builder(code, options) {\n    let instance;\n    let wc;\n    let memory;\n    options = options || {};\n\n    // Only circom 2 implements version lookup through exports in the WASM\n    // We default to `1` and update if we see the `getVersion` export (major version)\n    // These are updated after the instance is instantiated, assuming the functions are available\n    let majorVersion = 1;\n    // After Circom 2.0.7, Blaine added exported functions for getting minor and patch versions\n    let minorVersion = 0;\n    // If we can't look up the patch version, assume the lowest\n    let patchVersion = 0;\n\n    let codeIsWebAssemblyInstance = false;\n\n    // If code is already prepared WebAssembly.Instance, we use it directly\n    if (code instanceof WebAssembly.Instance) {\n        instance = code;\n        codeIsWebAssemblyInstance = true;\n    } else {\n        let memorySize = 32767;\n\n        if (options.memorySize) {\n            // make sure we have int\n            memorySize = parseInt(options.memorySize);\n            if (memorySize < 0) {\n                throw new Error(\"Invalid memory size\");\n            }\n        }\n\n        let memoryAllocated = false;\n        while (!memoryAllocated) {\n            try {\n                memory = new WebAssembly.Memory({initial: memorySize});\n                memoryAllocated = true;\n            } catch (err) {\n                if (memorySize <= 1) {\n                    throw err;\n                }\n                console.warn(\"Could not allocate \" + memorySize * 1024 * 64 + \" bytes. This may cause severe instability. Trying with \" + memorySize * 1024 * 64 / 2 + \" bytes\");\n                memorySize = Math.floor(memorySize / 2);\n            }\n        }\n\n        const wasmModule = await WebAssembly.compile(code);\n\n        let errStr = \"\";\n        let msgStr = \"\";\n\n        instance = await WebAssembly.instantiate(wasmModule, {\n            env: {\n                \"memory\": memory\n            },\n            runtime: {\n                printDebug : function(value) {\n                    console.log(\"printDebug:\", value);\n                },\n                exceptionHandler: function (code) {\n                    let err;\n                    if (code === 1) {\n                        err = \"Signal not found. \";\n                    } else if (code === 2) {\n                        err = \"Too many signals set. \";\n                    } else if (code === 3) {\n                        err = \"Signal already set. \";\n                    } else if (code === 4) {\n                        err = \"Assert Failed. \";\n                    } else if (code === 5) {\n                        err = \"Not enough memory. \";\n                    } else if (code === 6) {\n                        err = \"Input signal array access exceeds the size. \";\n                    } else {\n                        err = \"Unknown error. \";\n                    }\n                    console.error(\"ERROR: \", code, errStr);\n                    throw new Error(err + errStr);\n                },\n                // A new way of logging messages was added in Circom 2.0.7 that requires 2 new imports\n                // `printErrorMessage` and `writeBufferMessage`.\n                printErrorMessage: function () {\n                    errStr += getMessage() + \"\\n\";\n                },\n                writeBufferMessage: function () {\n                    const msg = getMessage();\n                    // Any calls to `log()` will always end with a `\\n`, so that's when we print and reset\n                    if (msg === \"\\n\") {\n                        console.log(msgStr);\n                        msgStr = \"\";\n                    } else {\n                        // If we've buffered other content, put a space in between the items\n                        if (msgStr !== \"\") {\n                            msgStr += \" \";\n                        }\n                        // Then append the message to the message we are creating\n                        msgStr += msg;\n                    }\n                },\n                showSharedRWMemory: function () {\n                    const shared_rw_memory_size = instance.exports.getFieldNumLen32();\n                    const arr = new Uint32Array(shared_rw_memory_size);\n                    for (let j = 0; j < shared_rw_memory_size; j++) {\n                        arr[shared_rw_memory_size - 1 - j] = instance.exports.readSharedRWMemory(j);\n                    }\n\n                    // In circom 2.0.7, they changed the log() function to allow strings and changed the\n                    // output API. This smoothes over the breaking change.\n                    if (majorVersion >= 2 && (minorVersion >= 1 || patchVersion >= 7)) {\n                        // If we've buffered other content, put a space in between the items\n                        if (msgStr !== \"\") {\n                            msgStr += \" \";\n                        }\n                        // Then append the value to the message we are creating\n                        const msg = (ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.fromArray(arr, 0x100000000).toString());\n                        msgStr += msg;\n                    } else {\n                        console.log(ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.fromArray(arr, 0x100000000));\n                    }\n                },\n                error: function (code, pstr, a, b, c, d) {\n                    let errStr;\n                    if (code === 7) {\n                        errStr = p2str(pstr) + \" \" + wc.getFr(b).toString() + \" != \" + wc.getFr(c).toString() + \" \" + p2str(d);\n                    } else if (code === 9) {\n                        errStr = p2str(pstr) + \" \" + wc.getFr(b).toString() + \" \" + p2str(c);\n                    } else if ((code === 5) && (options.sym)) {\n                        errStr = p2str(pstr) + \" \" + options.sym.labelIdx2Name[c];\n                    } else {\n                        errStr = p2str(pstr) + \" \" + a + \" \" + b + \" \" + c + \" \" + d;\n                    }\n                    console.log(\"ERROR: \", code, errStr);\n                    throw new Error(errStr);\n                },\n                log: function (a) {\n                    console.log(wc.getFr(a).toString());\n                },\n                logGetSignal: function (signal, pVal) {\n                    if (options.logGetSignal) {\n                        options.logGetSignal(signal, wc.getFr(pVal));\n                    }\n                },\n                logSetSignal: function (signal, pVal) {\n                    if (options.logSetSignal) {\n                        options.logSetSignal(signal, wc.getFr(pVal));\n                    }\n                },\n                logStartComponent: function (cIdx) {\n                    if (options.logStartComponent) {\n                        options.logStartComponent(cIdx);\n                    }\n                },\n                logFinishComponent: function (cIdx) {\n                    if (options.logFinishComponent) {\n                        options.logFinishComponent(cIdx);\n                    }\n                }\n            }\n        });\n    }\n\n    if (typeof instance.exports.getVersion == \"function\") {\n        majorVersion = instance.exports.getVersion();\n    }\n    if (typeof instance.exports.getMinorVersion == \"function\") {\n        minorVersion = instance.exports.getMinorVersion();\n    }\n    if (typeof instance.exports.getPatchVersion == \"function\") {\n        patchVersion = instance.exports.getPatchVersion();\n    }\n\n    const sanityCheck =\n        options &&\n        (\n            options.sanityCheck ||\n            options.logGetSignal ||\n            options.logSetSignal ||\n            options.logStartComponent ||\n            options.logFinishComponent\n        );\n\n    // We explicitly check for major version 2 in case there's a circom v3 in the future\n    if (majorVersion === 2) {\n        wc = new WitnessCalculatorCircom2(instance, sanityCheck);\n    } else if (majorVersion === 1) {\n        if (codeIsWebAssemblyInstance) {\n            throw new Error('Loading code from WebAssembly instance is not supported for circom version 1');\n        }\n        wc = new WitnessCalculatorCircom1(memory, instance, sanityCheck);\n    } else {\n        throw new Error(`Unsupported circom version: ${majorVersion}`);\n    }\n    return wc;\n\n    function getMessage() {\n        let message = \"\";\n        let c = instance.exports.getMessageChar();\n        while (c !== 0) {\n            message += String.fromCharCode(c);\n            c = instance.exports.getMessageChar();\n        }\n        return message;\n    }\n\n    function p2str(p) {\n        const i8 = new Uint8Array(memory.buffer);\n\n        const bytes = [];\n\n        for (let i = 0; i8[p + i] > 0; i++) bytes.push(i8[p + i]);\n\n        return String.fromCharCode.apply(null, bytes);\n    }\n}\n\nclass WitnessCalculatorCircom1 {\n    constructor(memory, instance, sanityCheck) {\n        this.memory = memory;\n        this.i32 = new Uint32Array(memory.buffer);\n        this.instance = instance;\n\n        this.n32 = (this.instance.exports.getFrLen() >> 2) - 2;\n        const pRawPrime = this.instance.exports.getPRawPrime();\n\n        const arr = new Array(this.n32);\n        for (let i = 0; i < this.n32; i++) {\n            arr[this.n32 - 1 - i] = this.i32[(pRawPrime >> 2) + i];\n        }\n\n        this.prime = ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.fromArray(arr, 0x100000000);\n\n        this.Fr = new ffjavascript__WEBPACK_IMPORTED_MODULE_1__.F1Field(this.prime);\n\n        this.mask32 = ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.fromString(\"FFFFFFFF\", 16);\n        this.NVars = this.instance.exports.getNVars();\n        this.n64 = Math.floor((this.Fr.bitLength - 1) / 64) + 1;\n        this.R = this.Fr.e(ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.shiftLeft(1, this.n64 * 64));\n        this.RInv = this.Fr.inv(this.R);\n        this.sanityCheck = sanityCheck;\n    }\n\n    circom_version() {\n        return 1;\n    }\n\n    async _doCalculateWitness(input, sanityCheck) {\n        this.instance.exports.init((this.sanityCheck || sanityCheck) ? 1 : 0);\n        const pSigOffset = this.allocInt();\n        const pFr = this.allocFr();\n        const keys = Object.keys(input);\n        keys.forEach((k) => {\n            const h = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.fnvHash)(k);\n            const hMSB = parseInt(h.slice(0, 8), 16);\n            const hLSB = parseInt(h.slice(8, 16), 16);\n            try {\n                this.instance.exports.getSignalOffset32(pSigOffset, 0, hMSB, hLSB);\n            } catch (err) {\n                throw new Error(`Signal ${k} is not an input of the circuit.`);\n            }\n            const sigOffset = this.getInt(pSigOffset);\n            const fArr = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatArray)(input[k]);\n            for (let i = 0; i < fArr.length; i++) {\n                this.setFr(pFr, fArr[i]);\n                this.instance.exports.setSignal(0, 0, sigOffset + i, pFr);\n            }\n        });\n    }\n\n    async calculateWitness(input, sanityCheck) {\n        const self = this;\n\n        const old0 = self.i32[0];\n        const w = [];\n\n        await self._doCalculateWitness(input, sanityCheck);\n\n        for (let i = 0; i < self.NVars; i++) {\n            const pWitness = self.instance.exports.getPWitness(i);\n            w.push(self.getFr(pWitness));\n        }\n\n        self.i32[0] = old0;\n        return w;\n    }\n\n    async calculateBinWitness(input, sanityCheck) {\n        const self = this;\n\n        const old0 = self.i32[0];\n\n        await self._doCalculateWitness(input, sanityCheck);\n\n        const pWitnessBuffer = self.instance.exports.getWitnessBuffer();\n\n        self.i32[0] = old0;\n\n        const buff = self.memory.buffer.slice(pWitnessBuffer, pWitnessBuffer + (self.NVars * self.n64 * 8));\n        return new Uint8Array(buff);\n    }\n\n    allocInt() {\n        const p = this.i32[0];\n        this.i32[0] = p + 8;\n        return p;\n    }\n\n    allocFr() {\n        const p = this.i32[0];\n        this.i32[0] = p + this.n32 * 4 + 8;\n        return p;\n    }\n\n    getInt(p) {\n        return this.i32[p >> 2];\n    }\n\n    setInt(p, v) {\n        this.i32[p >> 2] = v;\n    }\n\n    getFr(p) {\n        const self = this;\n        const idx = (p >> 2);\n\n        if (self.i32[idx + 1] & 0x80000000) {\n            const arr = new Array(self.n32);\n            for (let i = 0; i < self.n32; i++) {\n                arr[self.n32 - 1 - i] = self.i32[idx + 2 + i];\n            }\n            const res = self.Fr.e(ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.fromArray(arr, 0x100000000));\n            if (self.i32[idx + 1] & 0x40000000) {\n                return fromMontgomery(res);\n            } else {\n                return res;\n            }\n\n        } else {\n            if (self.i32[idx] & 0x80000000) {\n                return self.Fr.e(self.i32[idx] - 0x100000000);\n            } else {\n                return self.Fr.e(self.i32[idx]);\n            }\n        }\n\n        function fromMontgomery(n) {\n            return self.Fr.mul(self.RInv, n);\n        }\n\n    }\n\n\n    setFr(p, v) {\n        const self = this;\n\n        v = self.Fr.e(v);\n\n        const minShort = self.Fr.neg(self.Fr.e(\"80000000\", 16));\n        const maxShort = self.Fr.e(\"7FFFFFFF\", 16);\n\n        if ((self.Fr.geq(v, minShort))\n            && (self.Fr.leq(v, maxShort))) {\n            let a;\n            if (self.Fr.geq(v, self.Fr.zero)) {\n                a = ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.toNumber(v);\n            } else {\n                a = ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.toNumber(self.Fr.sub(v, minShort));\n                a = a - 0x80000000;\n                a = 0x100000000 + a;\n            }\n            self.i32[(p >> 2)] = a;\n            self.i32[(p >> 2) + 1] = 0;\n            return;\n        }\n\n        self.i32[(p >> 2)] = 0;\n        self.i32[(p >> 2) + 1] = 0x80000000;\n        const arr = ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.toArray(v, 0x100000000);\n        for (let i = 0; i < self.n32; i++) {\n            const idx = arr.length - 1 - i;\n\n            if (idx >= 0) {\n                self.i32[(p >> 2) + 2 + i] = arr[idx];\n            } else {\n                self.i32[(p >> 2) + 2 + i] = 0;\n            }\n        }\n    }\n}\n\nclass WitnessCalculatorCircom2 {\n    constructor(instance, sanityCheck) {\n        this.instance = instance;\n\n        this.version = this.instance.exports.getVersion();\n        this.n32 = this.instance.exports.getFieldNumLen32();\n\n        this.instance.exports.getRawPrime();\n        const arr = new Uint32Array(this.n32);\n        for (let i = 0; i < this.n32; i++) {\n            arr[this.n32 - 1 - i] = this.instance.exports.readSharedRWMemory(i);\n        }\n        this.prime = ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.fromArray(arr, 0x100000000);\n\n        this.witnessSize = this.instance.exports.getWitnessSize();\n\n        this.sanityCheck = sanityCheck;\n    }\n\n    circom_version() {\n        return this.instance.exports.getVersion();\n    }\n\n    async _doCalculateWitness(input, sanityCheck) {\n        //input is assumed to be a map from signals to arrays of bigints\n        this.instance.exports.init((this.sanityCheck || sanityCheck) ? 1 : 0);\n        const keys = Object.keys(input);\n        let input_counter = 0;\n        keys.forEach((k) => {\n            const h = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.fnvHash)(k);\n            const hMSB = parseInt(h.slice(0, 8), 16);\n            const hLSB = parseInt(h.slice(8, 16), 16);\n            const fArr = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatArray)(input[k]);\n            // Slight deviation from https://github.com/iden3/circom/blob/v2.1.6/code_producers/src/wasm_elements/common/witness_calculator.js\n            // because I don't know when this exported function was added\n            if (typeof this.instance.exports.getInputSignalSize === \"function\") {\n                let signalSize = this.instance.exports.getInputSignalSize(hMSB, hLSB);\n                if (signalSize < 0) {\n                    throw new Error(`Signal ${k} not found\\n`);\n                }\n                if (fArr.length < signalSize) {\n                    throw new Error(`Not enough values for input signal ${k}\\n`);\n                }\n                if (fArr.length > signalSize) {\n                    throw new Error(`Too many values for input signal ${k}\\n`);\n                }\n            }\n            for (let i = 0; i < fArr.length; i++) {\n                const arrFr = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray32)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.normalize)(fArr[i], this.prime), this.n32);\n                for (let j = 0; j < this.n32; j++) {\n                    this.instance.exports.writeSharedRWMemory(j, arrFr[this.n32 - 1 - j]);\n                }\n                try {\n                    this.instance.exports.setInputSignal(hMSB, hLSB, i);\n                    input_counter++;\n                } catch (err) {\n                    // console.log(`After adding signal ${i} of ${k}`)\n                    throw new Error(err);\n                }\n            }\n\n        });\n        if (input_counter < this.instance.exports.getInputSize()) {\n            throw new Error(`Not all inputs have been set. Only ${input_counter} out of ${this.instance.exports.getInputSize()}`);\n        }\n    }\n\n    async calculateWitness(input, sanityCheck) {\n        const w = [];\n\n        await this._doCalculateWitness(input, sanityCheck);\n\n        for (let i = 0; i < this.witnessSize; i++) {\n            this.instance.exports.getWitness(i);\n            const arr = new Uint32Array(this.n32);\n            for (let j = 0; j < this.n32; j++) {\n                arr[this.n32 - 1 - j] = this.instance.exports.readSharedRWMemory(j);\n            }\n            w.push(ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.fromArray(arr, 0x100000000));\n        }\n\n        return w;\n    }\n\n    async calculateWTNSBin(input, sanityCheck) {\n        const buff32 = new Uint32Array(this.witnessSize * this.n32 + this.n32 + 11);\n        const buff = new Uint8Array(buff32.buffer);\n        await this._doCalculateWitness(input, sanityCheck);\n\n        //\"wtns\"\n        buff[0] = \"w\".charCodeAt(0);\n        buff[1] = \"t\".charCodeAt(0);\n        buff[2] = \"n\".charCodeAt(0);\n        buff[3] = \"s\".charCodeAt(0);\n\n        //version 2\n        buff32[1] = 2;\n\n        //number of sections: 2\n        buff32[2] = 2;\n\n        //id section 1\n        buff32[3] = 1;\n\n        const n8 = this.n32 * 4;\n        //id section 1 length in 64bytes\n        const idSection1length = 8 + n8;\n        const idSection1lengthHex = idSection1length.toString(16);\n        buff32[4] = parseInt(idSection1lengthHex.slice(0, 8), 16);\n        buff32[5] = parseInt(idSection1lengthHex.slice(8, 16), 16);\n\n        //this.n32\n        buff32[6] = n8;\n\n        //prime number\n        this.instance.exports.getRawPrime();\n\n        let pos = 7;\n        for (let j = 0; j < this.n32; j++) {\n            buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);\n        }\n        pos += this.n32;\n\n        // witness size\n        buff32[pos] = this.witnessSize;\n        pos++;\n\n        //id section 2\n        buff32[pos] = 2;\n        pos++;\n\n        // section 2 length\n        const idSection2length = n8 * this.witnessSize;\n        const idSection2lengthHex = idSection2length.toString(16);\n        buff32[pos] = parseInt(idSection2lengthHex.slice(0, 8), 16);\n        buff32[pos + 1] = parseInt(idSection2lengthHex.slice(8, 16), 16);\n\n        pos += 2;\n        for (let i = 0; i < this.witnessSize; i++) {\n            this.instance.exports.getWitness(i);\n            for (let j = 0; j < this.n32; j++) {\n                buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);\n            }\n            pos += this.n32;\n        }\n\n        return buff;\n    }\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2lyY29tX3J1bnRpbWUvanMvd2l0bmVzc19jYWxjdWxhdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRW9FO0FBQ3ZCOztBQUU5QjtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG9CQUFvQjtBQUNyRTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyQkFBMkI7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdEQUFNO0FBQzNDO0FBQ0Esc0JBQXNCO0FBQ3RCLG9DQUFvQyxnREFBTTtBQUMxQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix1REFBdUQsYUFBYTtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QixlQUFlOztBQUV2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTs7QUFFQSxxQkFBcUIsZ0RBQU07O0FBRTNCLHNCQUFzQixpREFBTzs7QUFFN0Isc0JBQXNCLGdEQUFNO0FBQzVCO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQU07QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0RBQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsMENBQTBDLEdBQUc7QUFDN0M7QUFDQTtBQUNBLHlCQUF5QixvREFBUztBQUNsQyw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBLGtDQUFrQyxnREFBTTtBQUN4QztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdEQUFNO0FBQzFCLGNBQWM7QUFDZCxvQkFBb0IsZ0RBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixnREFBTTtBQUMxQix3QkFBd0IsY0FBYztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQSxxQkFBcUIsZ0RBQU07O0FBRTNCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrREFBTztBQUM3QjtBQUNBO0FBQ0EseUJBQXlCLG9EQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsR0FBRztBQUNqRDtBQUNBO0FBQ0EsMEVBQTBFLEVBQUU7QUFDNUU7QUFDQTtBQUNBLHdFQUF3RSxFQUFFO0FBQzFFO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDLDhCQUE4QixvREFBUyxDQUFDLG9EQUFTO0FBQ2pELGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsMERBQTBELEdBQUcsS0FBSyxFQUFFO0FBQ3BFO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQSxrRUFBa0UsZUFBZSxTQUFTLHFDQUFxQztBQUMvSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBLG1CQUFtQixnREFBTTtBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvY2lyY29tX3J1bnRpbWUvanMvd2l0bmVzc19jYWxjdWxhdG9yLmpzP2RhZTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFscyBXZWJBc3NlbWJseSAqL1xuLypcblxuQ29weXJpZ2h0IDIwMjAgMEtJTVMgYXNzb2NpYXRpb24uXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQge2ZsYXRBcnJheSwgZm52SGFzaCwgdG9BcnJheTMyLCBub3JtYWxpemV9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5pbXBvcnQge1NjYWxhciwgRjFGaWVsZH0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBidWlsZGVyKGNvZGUsIG9wdGlvbnMpIHtcbiAgICBsZXQgaW5zdGFuY2U7XG4gICAgbGV0IHdjO1xuICAgIGxldCBtZW1vcnk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBPbmx5IGNpcmNvbSAyIGltcGxlbWVudHMgdmVyc2lvbiBsb29rdXAgdGhyb3VnaCBleHBvcnRzIGluIHRoZSBXQVNNXG4gICAgLy8gV2UgZGVmYXVsdCB0byBgMWAgYW5kIHVwZGF0ZSBpZiB3ZSBzZWUgdGhlIGBnZXRWZXJzaW9uYCBleHBvcnQgKG1ham9yIHZlcnNpb24pXG4gICAgLy8gVGhlc2UgYXJlIHVwZGF0ZWQgYWZ0ZXIgdGhlIGluc3RhbmNlIGlzIGluc3RhbnRpYXRlZCwgYXNzdW1pbmcgdGhlIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlXG4gICAgbGV0IG1ham9yVmVyc2lvbiA9IDE7XG4gICAgLy8gQWZ0ZXIgQ2lyY29tIDIuMC43LCBCbGFpbmUgYWRkZWQgZXhwb3J0ZWQgZnVuY3Rpb25zIGZvciBnZXR0aW5nIG1pbm9yIGFuZCBwYXRjaCB2ZXJzaW9uc1xuICAgIGxldCBtaW5vclZlcnNpb24gPSAwO1xuICAgIC8vIElmIHdlIGNhbid0IGxvb2sgdXAgdGhlIHBhdGNoIHZlcnNpb24sIGFzc3VtZSB0aGUgbG93ZXN0XG4gICAgbGV0IHBhdGNoVmVyc2lvbiA9IDA7XG5cbiAgICBsZXQgY29kZUlzV2ViQXNzZW1ibHlJbnN0YW5jZSA9IGZhbHNlO1xuXG4gICAgLy8gSWYgY29kZSBpcyBhbHJlYWR5IHByZXBhcmVkIFdlYkFzc2VtYmx5Lkluc3RhbmNlLCB3ZSB1c2UgaXQgZGlyZWN0bHlcbiAgICBpZiAoY29kZSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lkluc3RhbmNlKSB7XG4gICAgICAgIGluc3RhbmNlID0gY29kZTtcbiAgICAgICAgY29kZUlzV2ViQXNzZW1ibHlJbnN0YW5jZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IG1lbW9yeVNpemUgPSAzMjc2NztcblxuICAgICAgICBpZiAob3B0aW9ucy5tZW1vcnlTaXplKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgaGF2ZSBpbnRcbiAgICAgICAgICAgIG1lbW9yeVNpemUgPSBwYXJzZUludChvcHRpb25zLm1lbW9yeVNpemUpO1xuICAgICAgICAgICAgaWYgKG1lbW9yeVNpemUgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtZW1vcnkgc2l6ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZW1vcnlBbGxvY2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKCFtZW1vcnlBbGxvY2F0ZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDogbWVtb3J5U2l6ZX0pO1xuICAgICAgICAgICAgICAgIG1lbW9yeUFsbG9jYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVtb3J5U2l6ZSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGFsbG9jYXRlIFwiICsgbWVtb3J5U2l6ZSAqIDEwMjQgKiA2NCArIFwiIGJ5dGVzLiBUaGlzIG1heSBjYXVzZSBzZXZlcmUgaW5zdGFiaWxpdHkuIFRyeWluZyB3aXRoIFwiICsgbWVtb3J5U2l6ZSAqIDEwMjQgKiA2NCAvIDIgKyBcIiBieXRlc1wiKTtcbiAgICAgICAgICAgICAgICBtZW1vcnlTaXplID0gTWF0aC5mbG9vcihtZW1vcnlTaXplIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB3YXNtTW9kdWxlID0gYXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZShjb2RlKTtcblxuICAgICAgICBsZXQgZXJyU3RyID0gXCJcIjtcbiAgICAgICAgbGV0IG1zZ1N0ciA9IFwiXCI7XG5cbiAgICAgICAgaW5zdGFuY2UgPSBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZSh3YXNtTW9kdWxlLCB7XG4gICAgICAgICAgICBlbnY6IHtcbiAgICAgICAgICAgICAgICBcIm1lbW9yeVwiOiBtZW1vcnlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydW50aW1lOiB7XG4gICAgICAgICAgICAgICAgcHJpbnREZWJ1ZyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicHJpbnREZWJ1ZzpcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXhjZXB0aW9uSGFuZGxlcjogZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVycjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IFwiU2lnbmFsIG5vdCBmb3VuZC4gXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gXCJUb28gbWFueSBzaWduYWxzIHNldC4gXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gXCJTaWduYWwgYWxyZWFkeSBzZXQuIFwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IFwiQXNzZXJ0IEZhaWxlZC4gXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gXCJOb3QgZW5vdWdoIG1lbW9yeS4gXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gXCJJbnB1dCBzaWduYWwgYXJyYXkgYWNjZXNzIGV4Y2VlZHMgdGhlIHNpemUuIFwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gXCJVbmtub3duIGVycm9yLiBcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRVJST1I6IFwiLCBjb2RlLCBlcnJTdHIpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyICsgZXJyU3RyKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIEEgbmV3IHdheSBvZiBsb2dnaW5nIG1lc3NhZ2VzIHdhcyBhZGRlZCBpbiBDaXJjb20gMi4wLjcgdGhhdCByZXF1aXJlcyAyIG5ldyBpbXBvcnRzXG4gICAgICAgICAgICAgICAgLy8gYHByaW50RXJyb3JNZXNzYWdlYCBhbmQgYHdyaXRlQnVmZmVyTWVzc2FnZWAuXG4gICAgICAgICAgICAgICAgcHJpbnRFcnJvck1lc3NhZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyU3RyICs9IGdldE1lc3NhZ2UoKSArIFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3cml0ZUJ1ZmZlck1lc3NhZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbXNnID0gZ2V0TWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBbnkgY2FsbHMgdG8gYGxvZygpYCB3aWxsIGFsd2F5cyBlbmQgd2l0aCBhIGBcXG5gLCBzbyB0aGF0J3Mgd2hlbiB3ZSBwcmludCBhbmQgcmVzZXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1zZyA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobXNnU3RyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZ1N0ciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSBidWZmZXJlZCBvdGhlciBjb250ZW50LCBwdXQgYSBzcGFjZSBpbiBiZXR3ZWVuIHRoZSBpdGVtc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1zZ1N0ciAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zZ1N0ciArPSBcIiBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZW4gYXBwZW5kIHRoZSBtZXNzYWdlIHRvIHRoZSBtZXNzYWdlIHdlIGFyZSBjcmVhdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgbXNnU3RyICs9IG1zZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2hvd1NoYXJlZFJXTWVtb3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoYXJlZF9yd19tZW1vcnlfc2l6ZSA9IGluc3RhbmNlLmV4cG9ydHMuZ2V0RmllbGROdW1MZW4zMigpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDMyQXJyYXkoc2hhcmVkX3J3X21lbW9yeV9zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzaGFyZWRfcndfbWVtb3J5X3NpemU7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyW3NoYXJlZF9yd19tZW1vcnlfc2l6ZSAtIDEgLSBqXSA9IGluc3RhbmNlLmV4cG9ydHMucmVhZFNoYXJlZFJXTWVtb3J5KGopO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gY2lyY29tIDIuMC43LCB0aGV5IGNoYW5nZWQgdGhlIGxvZygpIGZ1bmN0aW9uIHRvIGFsbG93IHN0cmluZ3MgYW5kIGNoYW5nZWQgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIG91dHB1dCBBUEkuIFRoaXMgc21vb3RoZXMgb3ZlciB0aGUgYnJlYWtpbmcgY2hhbmdlLlxuICAgICAgICAgICAgICAgICAgICBpZiAobWFqb3JWZXJzaW9uID49IDIgJiYgKG1pbm9yVmVyc2lvbiA+PSAxIHx8IHBhdGNoVmVyc2lvbiA+PSA3KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgYnVmZmVyZWQgb3RoZXIgY29udGVudCwgcHV0IGEgc3BhY2UgaW4gYmV0d2VlbiB0aGUgaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtc2dTdHIgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2dTdHIgKz0gXCIgXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVuIGFwcGVuZCB0aGUgdmFsdWUgdG8gdGhlIG1lc3NhZ2Ugd2UgYXJlIGNyZWF0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSAoU2NhbGFyLmZyb21BcnJheShhcnIsIDB4MTAwMDAwMDAwKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZ1N0ciArPSBtc2c7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhTY2FsYXIuZnJvbUFycmF5KGFyciwgMHgxMDAwMDAwMDApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChjb2RlLCBwc3RyLCBhLCBiLCBjLCBkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlcnJTdHI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSA3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSBwMnN0cihwc3RyKSArIFwiIFwiICsgd2MuZ2V0RnIoYikudG9TdHJpbmcoKSArIFwiICE9IFwiICsgd2MuZ2V0RnIoYykudG9TdHJpbmcoKSArIFwiIFwiICsgcDJzdHIoZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gcDJzdHIocHN0cikgKyBcIiBcIiArIHdjLmdldEZyKGIpLnRvU3RyaW5nKCkgKyBcIiBcIiArIHAyc3RyKGMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChjb2RlID09PSA1KSAmJiAob3B0aW9ucy5zeW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSBwMnN0cihwc3RyKSArIFwiIFwiICsgb3B0aW9ucy5zeW0ubGFiZWxJZHgyTmFtZVtjXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyclN0ciA9IHAyc3RyKHBzdHIpICsgXCIgXCIgKyBhICsgXCIgXCIgKyBiICsgXCIgXCIgKyBjICsgXCIgXCIgKyBkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1I6IFwiLCBjb2RlLCBlcnJTdHIpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyU3RyKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxvZzogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cod2MuZ2V0RnIoYSkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsb2dHZXRTaWduYWw6IGZ1bmN0aW9uIChzaWduYWwsIHBWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9nR2V0U2lnbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxvZ0dldFNpZ25hbChzaWduYWwsIHdjLmdldEZyKHBWYWwpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbG9nU2V0U2lnbmFsOiBmdW5jdGlvbiAoc2lnbmFsLCBwVmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmxvZ1NldFNpZ25hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2dTZXRTaWduYWwoc2lnbmFsLCB3Yy5nZXRGcihwVmFsKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxvZ1N0YXJ0Q29tcG9uZW50OiBmdW5jdGlvbiAoY0lkeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5sb2dTdGFydENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2dTdGFydENvbXBvbmVudChjSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbG9nRmluaXNoQ29tcG9uZW50OiBmdW5jdGlvbiAoY0lkeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5sb2dGaW5pc2hDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubG9nRmluaXNoQ29tcG9uZW50KGNJZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmV4cG9ydHMuZ2V0VmVyc2lvbiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbWFqb3JWZXJzaW9uID0gaW5zdGFuY2UuZXhwb3J0cy5nZXRWZXJzaW9uKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZXhwb3J0cy5nZXRNaW5vclZlcnNpb24gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG1pbm9yVmVyc2lvbiA9IGluc3RhbmNlLmV4cG9ydHMuZ2V0TWlub3JWZXJzaW9uKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZXhwb3J0cy5nZXRQYXRjaFZlcnNpb24gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHBhdGNoVmVyc2lvbiA9IGluc3RhbmNlLmV4cG9ydHMuZ2V0UGF0Y2hWZXJzaW9uKCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2FuaXR5Q2hlY2sgPVxuICAgICAgICBvcHRpb25zICYmXG4gICAgICAgIChcbiAgICAgICAgICAgIG9wdGlvbnMuc2FuaXR5Q2hlY2sgfHxcbiAgICAgICAgICAgIG9wdGlvbnMubG9nR2V0U2lnbmFsIHx8XG4gICAgICAgICAgICBvcHRpb25zLmxvZ1NldFNpZ25hbCB8fFxuICAgICAgICAgICAgb3B0aW9ucy5sb2dTdGFydENvbXBvbmVudCB8fFxuICAgICAgICAgICAgb3B0aW9ucy5sb2dGaW5pc2hDb21wb25lbnRcbiAgICAgICAgKTtcblxuICAgIC8vIFdlIGV4cGxpY2l0bHkgY2hlY2sgZm9yIG1ham9yIHZlcnNpb24gMiBpbiBjYXNlIHRoZXJlJ3MgYSBjaXJjb20gdjMgaW4gdGhlIGZ1dHVyZVxuICAgIGlmIChtYWpvclZlcnNpb24gPT09IDIpIHtcbiAgICAgICAgd2MgPSBuZXcgV2l0bmVzc0NhbGN1bGF0b3JDaXJjb20yKGluc3RhbmNlLCBzYW5pdHlDaGVjayk7XG4gICAgfSBlbHNlIGlmIChtYWpvclZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgaWYgKGNvZGVJc1dlYkFzc2VtYmx5SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTG9hZGluZyBjb2RlIGZyb20gV2ViQXNzZW1ibHkgaW5zdGFuY2UgaXMgbm90IHN1cHBvcnRlZCBmb3IgY2lyY29tIHZlcnNpb24gMScpO1xuICAgICAgICB9XG4gICAgICAgIHdjID0gbmV3IFdpdG5lc3NDYWxjdWxhdG9yQ2lyY29tMShtZW1vcnksIGluc3RhbmNlLCBzYW5pdHlDaGVjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjaXJjb20gdmVyc2lvbjogJHttYWpvclZlcnNpb259YCk7XG4gICAgfVxuICAgIHJldHVybiB3YztcblxuICAgIGZ1bmN0aW9uIGdldE1lc3NhZ2UoKSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gXCJcIjtcbiAgICAgICAgbGV0IGMgPSBpbnN0YW5jZS5leHBvcnRzLmdldE1lc3NhZ2VDaGFyKCk7XG4gICAgICAgIHdoaWxlIChjICE9PSAwKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgICAgICBjID0gaW5zdGFuY2UuZXhwb3J0cy5nZXRNZXNzYWdlQ2hhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHAyc3RyKHApIHtcbiAgICAgICAgY29uc3QgaTggPSBuZXcgVWludDhBcnJheShtZW1vcnkuYnVmZmVyKTtcblxuICAgICAgICBjb25zdCBieXRlcyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpOFtwICsgaV0gPiAwOyBpKyspIGJ5dGVzLnB1c2goaThbcCArIGldKTtcblxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBieXRlcyk7XG4gICAgfVxufVxuXG5jbGFzcyBXaXRuZXNzQ2FsY3VsYXRvckNpcmNvbTEge1xuICAgIGNvbnN0cnVjdG9yKG1lbW9yeSwgaW5zdGFuY2UsIHNhbml0eUNoZWNrKSB7XG4gICAgICAgIHRoaXMubWVtb3J5ID0gbWVtb3J5O1xuICAgICAgICB0aGlzLmkzMiA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuXG4gICAgICAgIHRoaXMubjMyID0gKHRoaXMuaW5zdGFuY2UuZXhwb3J0cy5nZXRGckxlbigpID4+IDIpIC0gMjtcbiAgICAgICAgY29uc3QgcFJhd1ByaW1lID0gdGhpcy5pbnN0YW5jZS5leHBvcnRzLmdldFBSYXdQcmltZSgpO1xuXG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheSh0aGlzLm4zMik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uMzI7IGkrKykge1xuICAgICAgICAgICAgYXJyW3RoaXMubjMyIC0gMSAtIGldID0gdGhpcy5pMzJbKHBSYXdQcmltZSA+PiAyKSArIGldO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcmltZSA9IFNjYWxhci5mcm9tQXJyYXkoYXJyLCAweDEwMDAwMDAwMCk7XG5cbiAgICAgICAgdGhpcy5GciA9IG5ldyBGMUZpZWxkKHRoaXMucHJpbWUpO1xuXG4gICAgICAgIHRoaXMubWFzazMyID0gU2NhbGFyLmZyb21TdHJpbmcoXCJGRkZGRkZGRlwiLCAxNik7XG4gICAgICAgIHRoaXMuTlZhcnMgPSB0aGlzLmluc3RhbmNlLmV4cG9ydHMuZ2V0TlZhcnMoKTtcbiAgICAgICAgdGhpcy5uNjQgPSBNYXRoLmZsb29yKCh0aGlzLkZyLmJpdExlbmd0aCAtIDEpIC8gNjQpICsgMTtcbiAgICAgICAgdGhpcy5SID0gdGhpcy5Gci5lKFNjYWxhci5zaGlmdExlZnQoMSwgdGhpcy5uNjQgKiA2NCkpO1xuICAgICAgICB0aGlzLlJJbnYgPSB0aGlzLkZyLmludih0aGlzLlIpO1xuICAgICAgICB0aGlzLnNhbml0eUNoZWNrID0gc2FuaXR5Q2hlY2s7XG4gICAgfVxuXG4gICAgY2lyY29tX3ZlcnNpb24oKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGFzeW5jIF9kb0NhbGN1bGF0ZVdpdG5lc3MoaW5wdXQsIHNhbml0eUNoZWNrKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UuZXhwb3J0cy5pbml0KCh0aGlzLnNhbml0eUNoZWNrIHx8IHNhbml0eUNoZWNrKSA/IDEgOiAwKTtcbiAgICAgICAgY29uc3QgcFNpZ09mZnNldCA9IHRoaXMuYWxsb2NJbnQoKTtcbiAgICAgICAgY29uc3QgcEZyID0gdGhpcy5hbGxvY0ZyKCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpbnB1dCk7XG4gICAgICAgIGtleXMuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgaCA9IGZudkhhc2goayk7XG4gICAgICAgICAgICBjb25zdCBoTVNCID0gcGFyc2VJbnQoaC5zbGljZSgwLCA4KSwgMTYpO1xuICAgICAgICAgICAgY29uc3QgaExTQiA9IHBhcnNlSW50KGguc2xpY2UoOCwgMTYpLCAxNik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZXhwb3J0cy5nZXRTaWduYWxPZmZzZXQzMihwU2lnT2Zmc2V0LCAwLCBoTVNCLCBoTFNCKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2lnbmFsICR7a30gaXMgbm90IGFuIGlucHV0IG9mIHRoZSBjaXJjdWl0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2lnT2Zmc2V0ID0gdGhpcy5nZXRJbnQocFNpZ09mZnNldCk7XG4gICAgICAgICAgICBjb25zdCBmQXJyID0gZmxhdEFycmF5KGlucHV0W2tdKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZkFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RnIocEZyLCBmQXJyW2ldKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLmV4cG9ydHMuc2V0U2lnbmFsKDAsIDAsIHNpZ09mZnNldCArIGksIHBGcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGNhbGN1bGF0ZVdpdG5lc3MoaW5wdXQsIHNhbml0eUNoZWNrKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGNvbnN0IG9sZDAgPSBzZWxmLmkzMlswXTtcbiAgICAgICAgY29uc3QgdyA9IFtdO1xuXG4gICAgICAgIGF3YWl0IHNlbGYuX2RvQ2FsY3VsYXRlV2l0bmVzcyhpbnB1dCwgc2FuaXR5Q2hlY2spO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZi5OVmFyczsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwV2l0bmVzcyA9IHNlbGYuaW5zdGFuY2UuZXhwb3J0cy5nZXRQV2l0bmVzcyhpKTtcbiAgICAgICAgICAgIHcucHVzaChzZWxmLmdldEZyKHBXaXRuZXNzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmkzMlswXSA9IG9sZDA7XG4gICAgICAgIHJldHVybiB3O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbGN1bGF0ZUJpbldpdG5lc3MoaW5wdXQsIHNhbml0eUNoZWNrKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGNvbnN0IG9sZDAgPSBzZWxmLmkzMlswXTtcblxuICAgICAgICBhd2FpdCBzZWxmLl9kb0NhbGN1bGF0ZVdpdG5lc3MoaW5wdXQsIHNhbml0eUNoZWNrKTtcblxuICAgICAgICBjb25zdCBwV2l0bmVzc0J1ZmZlciA9IHNlbGYuaW5zdGFuY2UuZXhwb3J0cy5nZXRXaXRuZXNzQnVmZmVyKCk7XG5cbiAgICAgICAgc2VsZi5pMzJbMF0gPSBvbGQwO1xuXG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBzZWxmLm1lbW9yeS5idWZmZXIuc2xpY2UocFdpdG5lc3NCdWZmZXIsIHBXaXRuZXNzQnVmZmVyICsgKHNlbGYuTlZhcnMgKiBzZWxmLm42NCAqIDgpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmYpO1xuICAgIH1cblxuICAgIGFsbG9jSW50KCkge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5pMzJbMF07XG4gICAgICAgIHRoaXMuaTMyWzBdID0gcCArIDg7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIGFsbG9jRnIoKSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmkzMlswXTtcbiAgICAgICAgdGhpcy5pMzJbMF0gPSBwICsgdGhpcy5uMzIgKiA0ICsgODtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgZ2V0SW50KHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaTMyW3AgPj4gMl07XG4gICAgfVxuXG4gICAgc2V0SW50KHAsIHYpIHtcbiAgICAgICAgdGhpcy5pMzJbcCA+PiAyXSA9IHY7XG4gICAgfVxuXG4gICAgZ2V0RnIocCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgaWR4ID0gKHAgPj4gMik7XG5cbiAgICAgICAgaWYgKHNlbGYuaTMyW2lkeCArIDFdICYgMHg4MDAwMDAwMCkge1xuICAgICAgICAgICAgY29uc3QgYXJyID0gbmV3IEFycmF5KHNlbGYubjMyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZi5uMzI7IGkrKykge1xuICAgICAgICAgICAgICAgIGFycltzZWxmLm4zMiAtIDEgLSBpXSA9IHNlbGYuaTMyW2lkeCArIDIgKyBpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHNlbGYuRnIuZShTY2FsYXIuZnJvbUFycmF5KGFyciwgMHgxMDAwMDAwMDApKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmkzMltpZHggKyAxXSAmIDB4NDAwMDAwMDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbU1vbnRnb21lcnkocmVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNlbGYuaTMyW2lkeF0gJiAweDgwMDAwMDAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuRnIuZShzZWxmLmkzMltpZHhdIC0gMHgxMDAwMDAwMDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5Gci5lKHNlbGYuaTMyW2lkeF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZnJvbU1vbnRnb21lcnkobikge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuRnIubXVsKHNlbGYuUkludiwgbik7XG4gICAgICAgIH1cblxuICAgIH1cblxuXG4gICAgc2V0RnIocCwgdikge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgICAgICB2ID0gc2VsZi5Gci5lKHYpO1xuXG4gICAgICAgIGNvbnN0IG1pblNob3J0ID0gc2VsZi5Gci5uZWcoc2VsZi5Gci5lKFwiODAwMDAwMDBcIiwgMTYpKTtcbiAgICAgICAgY29uc3QgbWF4U2hvcnQgPSBzZWxmLkZyLmUoXCI3RkZGRkZGRlwiLCAxNik7XG5cbiAgICAgICAgaWYgKChzZWxmLkZyLmdlcSh2LCBtaW5TaG9ydCkpXG4gICAgICAgICAgICAmJiAoc2VsZi5Gci5sZXEodiwgbWF4U2hvcnQpKSkge1xuICAgICAgICAgICAgbGV0IGE7XG4gICAgICAgICAgICBpZiAoc2VsZi5Gci5nZXEodiwgc2VsZi5Gci56ZXJvKSkge1xuICAgICAgICAgICAgICAgIGEgPSBTY2FsYXIudG9OdW1iZXIodik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGEgPSBTY2FsYXIudG9OdW1iZXIoc2VsZi5Gci5zdWIodiwgbWluU2hvcnQpKTtcbiAgICAgICAgICAgICAgICBhID0gYSAtIDB4ODAwMDAwMDA7XG4gICAgICAgICAgICAgICAgYSA9IDB4MTAwMDAwMDAwICsgYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuaTMyWyhwID4+IDIpXSA9IGE7XG4gICAgICAgICAgICBzZWxmLmkzMlsocCA+PiAyKSArIDFdID0gMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuaTMyWyhwID4+IDIpXSA9IDA7XG4gICAgICAgIHNlbGYuaTMyWyhwID4+IDIpICsgMV0gPSAweDgwMDAwMDAwO1xuICAgICAgICBjb25zdCBhcnIgPSBTY2FsYXIudG9BcnJheSh2LCAweDEwMDAwMDAwMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZi5uMzI7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gYXJyLmxlbmd0aCAtIDEgLSBpO1xuXG4gICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICBzZWxmLmkzMlsocCA+PiAyKSArIDIgKyBpXSA9IGFycltpZHhdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmkzMlsocCA+PiAyKSArIDIgKyBpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFdpdG5lc3NDYWxjdWxhdG9yQ2lyY29tMiB7XG4gICAgY29uc3RydWN0b3IoaW5zdGFuY2UsIHNhbml0eUNoZWNrKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcblxuICAgICAgICB0aGlzLnZlcnNpb24gPSB0aGlzLmluc3RhbmNlLmV4cG9ydHMuZ2V0VmVyc2lvbigpO1xuICAgICAgICB0aGlzLm4zMiA9IHRoaXMuaW5zdGFuY2UuZXhwb3J0cy5nZXRGaWVsZE51bUxlbjMyKCk7XG5cbiAgICAgICAgdGhpcy5pbnN0YW5jZS5leHBvcnRzLmdldFJhd1ByaW1lKCk7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50MzJBcnJheSh0aGlzLm4zMik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uMzI7IGkrKykge1xuICAgICAgICAgICAgYXJyW3RoaXMubjMyIC0gMSAtIGldID0gdGhpcy5pbnN0YW5jZS5leHBvcnRzLnJlYWRTaGFyZWRSV01lbW9yeShpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByaW1lID0gU2NhbGFyLmZyb21BcnJheShhcnIsIDB4MTAwMDAwMDAwKTtcblxuICAgICAgICB0aGlzLndpdG5lc3NTaXplID0gdGhpcy5pbnN0YW5jZS5leHBvcnRzLmdldFdpdG5lc3NTaXplKCk7XG5cbiAgICAgICAgdGhpcy5zYW5pdHlDaGVjayA9IHNhbml0eUNoZWNrO1xuICAgIH1cblxuICAgIGNpcmNvbV92ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZS5leHBvcnRzLmdldFZlcnNpb24oKTtcbiAgICB9XG5cbiAgICBhc3luYyBfZG9DYWxjdWxhdGVXaXRuZXNzKGlucHV0LCBzYW5pdHlDaGVjaykge1xuICAgICAgICAvL2lucHV0IGlzIGFzc3VtZWQgdG8gYmUgYSBtYXAgZnJvbSBzaWduYWxzIHRvIGFycmF5cyBvZiBiaWdpbnRzXG4gICAgICAgIHRoaXMuaW5zdGFuY2UuZXhwb3J0cy5pbml0KCh0aGlzLnNhbml0eUNoZWNrIHx8IHNhbml0eUNoZWNrKSA/IDEgOiAwKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGlucHV0KTtcbiAgICAgICAgbGV0IGlucHV0X2NvdW50ZXIgPSAwO1xuICAgICAgICBrZXlzLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGggPSBmbnZIYXNoKGspO1xuICAgICAgICAgICAgY29uc3QgaE1TQiA9IHBhcnNlSW50KGguc2xpY2UoMCwgOCksIDE2KTtcbiAgICAgICAgICAgIGNvbnN0IGhMU0IgPSBwYXJzZUludChoLnNsaWNlKDgsIDE2KSwgMTYpO1xuICAgICAgICAgICAgY29uc3QgZkFyciA9IGZsYXRBcnJheShpbnB1dFtrXSk7XG4gICAgICAgICAgICAvLyBTbGlnaHQgZGV2aWF0aW9uIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2lkZW4zL2NpcmNvbS9ibG9iL3YyLjEuNi9jb2RlX3Byb2R1Y2Vycy9zcmMvd2FzbV9lbGVtZW50cy9jb21tb24vd2l0bmVzc19jYWxjdWxhdG9yLmpzXG4gICAgICAgICAgICAvLyBiZWNhdXNlIEkgZG9uJ3Qga25vdyB3aGVuIHRoaXMgZXhwb3J0ZWQgZnVuY3Rpb24gd2FzIGFkZGVkXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuaW5zdGFuY2UuZXhwb3J0cy5nZXRJbnB1dFNpZ25hbFNpemUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGxldCBzaWduYWxTaXplID0gdGhpcy5pbnN0YW5jZS5leHBvcnRzLmdldElucHV0U2lnbmFsU2l6ZShoTVNCLCBoTFNCKTtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbmFsU2l6ZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaWduYWwgJHtrfSBub3QgZm91bmRcXG5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZBcnIubGVuZ3RoIDwgc2lnbmFsU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBlbm91Z2ggdmFsdWVzIGZvciBpbnB1dCBzaWduYWwgJHtrfVxcbmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZkFyci5sZW5ndGggPiBzaWduYWxTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9vIG1hbnkgdmFsdWVzIGZvciBpbnB1dCBzaWduYWwgJHtrfVxcbmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZkFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyckZyID0gdG9BcnJheTMyKG5vcm1hbGl6ZShmQXJyW2ldLCB0aGlzLnByaW1lKSwgdGhpcy5uMzIpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5uMzI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLmV4cG9ydHMud3JpdGVTaGFyZWRSV01lbW9yeShqLCBhcnJGclt0aGlzLm4zMiAtIDEgLSBqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZXhwb3J0cy5zZXRJbnB1dFNpZ25hbChoTVNCLCBoTFNCLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRfY291bnRlcisrO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgQWZ0ZXIgYWRkaW5nIHNpZ25hbCAke2l9IG9mICR7a31gKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbnB1dF9jb3VudGVyIDwgdGhpcy5pbnN0YW5jZS5leHBvcnRzLmdldElucHV0U2l6ZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBhbGwgaW5wdXRzIGhhdmUgYmVlbiBzZXQuIE9ubHkgJHtpbnB1dF9jb3VudGVyfSBvdXQgb2YgJHt0aGlzLmluc3RhbmNlLmV4cG9ydHMuZ2V0SW5wdXRTaXplKCl9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBjYWxjdWxhdGVXaXRuZXNzKGlucHV0LCBzYW5pdHlDaGVjaykge1xuICAgICAgICBjb25zdCB3ID0gW107XG5cbiAgICAgICAgYXdhaXQgdGhpcy5fZG9DYWxjdWxhdGVXaXRuZXNzKGlucHV0LCBzYW5pdHlDaGVjayk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndpdG5lc3NTaXplOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZXhwb3J0cy5nZXRXaXRuZXNzKGkpO1xuICAgICAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQzMkFycmF5KHRoaXMubjMyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5uMzI7IGorKykge1xuICAgICAgICAgICAgICAgIGFyclt0aGlzLm4zMiAtIDEgLSBqXSA9IHRoaXMuaW5zdGFuY2UuZXhwb3J0cy5yZWFkU2hhcmVkUldNZW1vcnkoaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3LnB1c2goU2NhbGFyLmZyb21BcnJheShhcnIsIDB4MTAwMDAwMDAwKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdztcbiAgICB9XG5cbiAgICBhc3luYyBjYWxjdWxhdGVXVE5TQmluKGlucHV0LCBzYW5pdHlDaGVjaykge1xuICAgICAgICBjb25zdCBidWZmMzIgPSBuZXcgVWludDMyQXJyYXkodGhpcy53aXRuZXNzU2l6ZSAqIHRoaXMubjMyICsgdGhpcy5uMzIgKyAxMSk7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShidWZmMzIuYnVmZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZG9DYWxjdWxhdGVXaXRuZXNzKGlucHV0LCBzYW5pdHlDaGVjayk7XG5cbiAgICAgICAgLy9cInd0bnNcIlxuICAgICAgICBidWZmWzBdID0gXCJ3XCIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgYnVmZlsxXSA9IFwidFwiLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGJ1ZmZbMl0gPSBcIm5cIi5jaGFyQ29kZUF0KDApO1xuICAgICAgICBidWZmWzNdID0gXCJzXCIuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICAvL3ZlcnNpb24gMlxuICAgICAgICBidWZmMzJbMV0gPSAyO1xuXG4gICAgICAgIC8vbnVtYmVyIG9mIHNlY3Rpb25zOiAyXG4gICAgICAgIGJ1ZmYzMlsyXSA9IDI7XG5cbiAgICAgICAgLy9pZCBzZWN0aW9uIDFcbiAgICAgICAgYnVmZjMyWzNdID0gMTtcblxuICAgICAgICBjb25zdCBuOCA9IHRoaXMubjMyICogNDtcbiAgICAgICAgLy9pZCBzZWN0aW9uIDEgbGVuZ3RoIGluIDY0Ynl0ZXNcbiAgICAgICAgY29uc3QgaWRTZWN0aW9uMWxlbmd0aCA9IDggKyBuODtcbiAgICAgICAgY29uc3QgaWRTZWN0aW9uMWxlbmd0aEhleCA9IGlkU2VjdGlvbjFsZW5ndGgudG9TdHJpbmcoMTYpO1xuICAgICAgICBidWZmMzJbNF0gPSBwYXJzZUludChpZFNlY3Rpb24xbGVuZ3RoSGV4LnNsaWNlKDAsIDgpLCAxNik7XG4gICAgICAgIGJ1ZmYzMls1XSA9IHBhcnNlSW50KGlkU2VjdGlvbjFsZW5ndGhIZXguc2xpY2UoOCwgMTYpLCAxNik7XG5cbiAgICAgICAgLy90aGlzLm4zMlxuICAgICAgICBidWZmMzJbNl0gPSBuODtcblxuICAgICAgICAvL3ByaW1lIG51bWJlclxuICAgICAgICB0aGlzLmluc3RhbmNlLmV4cG9ydHMuZ2V0UmF3UHJpbWUoKTtcblxuICAgICAgICBsZXQgcG9zID0gNztcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLm4zMjsgaisrKSB7XG4gICAgICAgICAgICBidWZmMzJbcG9zICsgal0gPSB0aGlzLmluc3RhbmNlLmV4cG9ydHMucmVhZFNoYXJlZFJXTWVtb3J5KGopO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSB0aGlzLm4zMjtcblxuICAgICAgICAvLyB3aXRuZXNzIHNpemVcbiAgICAgICAgYnVmZjMyW3Bvc10gPSB0aGlzLndpdG5lc3NTaXplO1xuICAgICAgICBwb3MrKztcblxuICAgICAgICAvL2lkIHNlY3Rpb24gMlxuICAgICAgICBidWZmMzJbcG9zXSA9IDI7XG4gICAgICAgIHBvcysrO1xuXG4gICAgICAgIC8vIHNlY3Rpb24gMiBsZW5ndGhcbiAgICAgICAgY29uc3QgaWRTZWN0aW9uMmxlbmd0aCA9IG44ICogdGhpcy53aXRuZXNzU2l6ZTtcbiAgICAgICAgY29uc3QgaWRTZWN0aW9uMmxlbmd0aEhleCA9IGlkU2VjdGlvbjJsZW5ndGgudG9TdHJpbmcoMTYpO1xuICAgICAgICBidWZmMzJbcG9zXSA9IHBhcnNlSW50KGlkU2VjdGlvbjJsZW5ndGhIZXguc2xpY2UoMCwgOCksIDE2KTtcbiAgICAgICAgYnVmZjMyW3BvcyArIDFdID0gcGFyc2VJbnQoaWRTZWN0aW9uMmxlbmd0aEhleC5zbGljZSg4LCAxNiksIDE2KTtcblxuICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndpdG5lc3NTaXplOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZXhwb3J0cy5nZXRXaXRuZXNzKGkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLm4zMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgYnVmZjMyW3BvcyArIGpdID0gdGhpcy5pbnN0YW5jZS5leHBvcnRzLnJlYWRTaGFyZWRSV01lbW9yeShqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSB0aGlzLm4zMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBidWZmO1xuICAgIH1cblxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/circom_runtime/js/witness_calculator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/circom_runtime/main.js":
/*!*********************************************!*\
  !*** ./node_modules/circom_runtime/main.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WitnessCalculatorBuilder: () => (/* reexport safe */ _js_witness_calculator_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _js_witness_calculator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./js/witness_calculator.js */ \"(ssr)/./node_modules/circom_runtime/js/witness_calculator.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2lyY29tX3J1bnRpbWUvbWFpbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpRiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvY2lyY29tX3J1bnRpbWUvbWFpbi5qcz8wYTZjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgYXMgV2l0bmVzc0NhbGN1bGF0b3JCdWlsZGVyIH0gZnJvbSBcIi4vanMvd2l0bmVzc19jYWxjdWxhdG9yLmpzXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/circom_runtime/main.js\n");

/***/ })

};
;