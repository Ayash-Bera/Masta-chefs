"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/maci-crypto";
exports.ids = ["vendor-chunks/maci-crypto"];
exports.modules = {

/***/ "(ssr)/./node_modules/maci-crypto/build/ts/AccQueue.js":
/*!*******************************************************!*\
  !*** ./node_modules/maci-crypto/build/ts/AccQueue.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AccQueue = void 0;\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst bigIntUtils_1 = __webpack_require__(/*! ./bigIntUtils */ \"(ssr)/./node_modules/maci-crypto/build/ts/bigIntUtils.js\");\nconst hashing_1 = __webpack_require__(/*! ./hashing */ \"(ssr)/./node_modules/maci-crypto/build/ts/hashing.js\");\nconst quinTree_1 = __webpack_require__(/*! ./quinTree */ \"(ssr)/./node_modules/maci-crypto/build/ts/quinTree.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/maci-crypto/build/ts/utils.js\");\n/**\n * An Accumulator Queue which conforms to the implementation in AccQueue.sol.\n * Each enqueue() operation updates a subtree, and a merge() operation combines\n * all subtrees into a main tree.\n * @notice It supports 2 or 5 elements per leaf.\n */\nclass AccQueue {\n    /**\n     * Create a new instance of AccQueue\n     * @param subDepth - the depth of the subtrees\n     * @param hashLength - the number of leaves per node\n     * @param zeroValue - the default value for empty leaves\n     */\n    constructor(subDepth, hashLength, zeroValue) {\n        // This class supports either 2 leaves per node, or 5 leaves per node.\n        // 5 is largest number of inputs which circomlib's Poseidon EVM hash\n        // function implementation supports.\n        this.MAX_DEPTH = 32;\n        // The current subtree index. e.g. the first subtree has index 0, the\n        // second has 1, and so on\n        this.currentSubtreeIndex = 0;\n        // The number of leaves across all subtrees\n        this.numLeaves = 0;\n        // The current subtree\n        this.leafQueue = {\n            levels: new Map(),\n            indices: [],\n        };\n        // For merging subtrees into the smallest tree\n        this.nextSRindexToQueue = 0;\n        this.smallSRTroot = 0n;\n        this.subRootQueue = {\n            levels: new Map(),\n            indices: [],\n        };\n        // The root of each complete subtree\n        this.subRoots = [];\n        // The root of merged subtrees\n        this.mainRoots = [];\n        // The zero value per level. i.e. zeros[0] is zeroValue,\n        // zeros[1] is the hash of leavesPerNode zeros, and so on.\n        this.zeros = [];\n        // Whether the subtrees have been merged\n        this.subTreesMerged = false;\n        /**\n         * Private function that performs the actual enqueue operation\n         * @param leaf - The leaf to insert\n         * @param level - The level of the subtree\n         */\n        this.enqueueOp = (leaf, level) => {\n            // small validation, do no throw\n            if (level > this.subDepth) {\n                return;\n            }\n            // get the index to determine where to insert the next leaf\n            const n = this.leafQueue.indices[level];\n            // we check that the index is not the last one (1 or 4 depending on the hash length)\n            if (n !== this.hashLength - 1) {\n                // Just store the leaf\n                this.leafQueue.levels.get(level)?.set(n, leaf);\n                this.leafQueue.indices[level] += 1;\n            }\n            else {\n                // if not we compute the root\n                let hashed;\n                if (this.hashLength === 2) {\n                    const subRoot = this.leafQueue.levels.get(level)?.get(0) ?? 0n;\n                    hashed = this.hashFunc([subRoot, leaf]);\n                    this.leafQueue.levels.get(level)?.set(0, 0n);\n                }\n                else {\n                    const levelSlice = this.leafQueue.levels.get(level) ?? new Map();\n                    hashed = this.hashFunc(Array.from(levelSlice.values()).concat(leaf));\n                    for (let i = 0; i < 4; i += 1) {\n                        this.leafQueue.levels.get(level)?.set(i, 0n);\n                    }\n                }\n                this.leafQueue.indices[level] = 0;\n                // Recurse\n                this.enqueueOp(hashed, level + 1);\n            }\n        };\n        (0, assert_1.default)(hashLength === 2 || hashLength === 5);\n        (0, assert_1.default)(subDepth > 0);\n        this.hashLength = hashLength;\n        this.subDepth = subDepth;\n        this.zeroValue = zeroValue;\n        // Set this.hashFunc depending on the number of leaves per node\n        if (this.hashLength === 2) {\n            // Uses PoseidonT3 under the hood, which accepts 2 inputs\n            this.hashFunc = (inputs) => (0, hashing_1.hashLeftRight)(inputs[0], inputs[1]);\n        }\n        else {\n            // Uses PoseidonT6 under the hood, which accepts up to 5 inputs\n            this.hashFunc = hashing_1.hash5;\n        }\n        this.subHashFunc = hashing_1.sha256Hash;\n        let hashed = this.zeroValue;\n        for (let i = 0; i < this.MAX_DEPTH; i += 1) {\n            this.zeros.push(hashed);\n            let e = [];\n            if (this.hashLength === 2) {\n                e = [0n];\n                hashed = this.hashFunc([hashed, hashed]);\n            }\n            else {\n                e = [0n, 0n, 0n, 0n];\n                hashed = this.hashFunc([hashed, hashed, hashed, hashed, hashed]);\n            }\n            const levels = new Map(Object.entries(e).map(([key, value]) => [Number(key), value]));\n            this.leafQueue.levels.set(this.leafQueue.levels.size, levels);\n            this.leafQueue.indices[i] = 0;\n            this.subRootQueue.levels.set(this.subRootQueue.levels.size, levels);\n            this.subRootQueue.indices[i] = 0;\n        }\n    }\n    /**\n     * Get the small SRT root\n     * @returns small SRT root\n     */\n    getSmallSRTroot() {\n        return this.smallSRTroot;\n    }\n    /**\n     * Get the subroots\n     * @returns subroots\n     */\n    getSubRoots() {\n        return this.subRoots;\n    }\n    /**\n     * Get the subdepth\n     * @returns subdepth\n     */\n    getSubDepth() {\n        return this.subDepth;\n    }\n    /**\n     * Get the root of merged subtrees\n     * @returns the root of merged subtrees\n     */\n    getMainRoots() {\n        return this.mainRoots;\n    }\n    /**\n     * Get the zero values per level. i.e. zeros[0] is zeroValue,\n     * zeros[1] is the hash of leavesPerNode zeros, and so on.\n     * @returns zeros\n     */\n    getZeros() {\n        return this.zeros;\n    }\n    /**\n     * Get the subroot at a given index\n     * @param index - The index of the subroot\n     * @returns the subroot\n     */\n    getSubRoot(index) {\n        return this.subRoots[index];\n    }\n    /**\n     * Get the number of inputs per hash function\n     *\n     * @returns the number of inputs\n     */\n    getHashLength() {\n        return this.hashLength;\n    }\n    /**\n     * Enqueue a leaf into the current subtree\n     * @param leaf The leaf to insert.\n     * @returns The index of the leaf\n     */\n    enqueue(leaf) {\n        // validation\n        (0, assert_1.default)(this.numLeaves < this.hashLength ** this.MAX_DEPTH, \"AccQueue is full\");\n        this.enqueueOp(leaf, 0);\n        // the index is the number of leaves (0-index)\n        const leafIndex = this.numLeaves;\n        // increase the number of leaves\n        this.numLeaves += 1;\n        // we set merged false because there are new leaves\n        this.subTreesMerged = false;\n        // reset the smallSRTroot because it is obsolete\n        this.smallSRTroot = 0n;\n        // @todo this can be moved in the constructor rather than computing every time\n        const subTreeCapacity = this.hashLength ** this.subDepth;\n        // If the current subtree is full\n        if (this.numLeaves % subTreeCapacity === 0) {\n            // store the subroot\n            const subRoot = this.leafQueue.levels.get(this.subDepth)?.get(0) ?? 0n;\n            this.subRoots[this.currentSubtreeIndex] = subRoot;\n            this.currentSubtreeIndex += 1;\n            // reset the current subtree\n            this.leafQueue.levels.get(this.subDepth)?.set(0, 0n);\n            for (let i = 0; i < this.MAX_DEPTH; i += 1) {\n                this.leafQueue.indices[i] = 0;\n            }\n        }\n        return leafIndex;\n    }\n    /**\n     * Fill any empty leaves of the last subtree with zeros and store the\n     * resulting subroot.\n     */\n    fill() {\n        // The total capacity of the subtree\n        const subTreeCapacity = this.hashLength ** this.subDepth;\n        if (this.numLeaves % subTreeCapacity === 0) {\n            // If the subtree is completely empty, then the subroot is a\n            // precalculated zero value\n            this.subRoots[this.currentSubtreeIndex] = this.zeros[this.subDepth];\n        }\n        else {\n            this.fillOp(0);\n            // Store the subroot\n            const subRoot = this.leafQueue.levels.get(this.subDepth)?.get(0) ?? 0n;\n            this.subRoots[this.currentSubtreeIndex] = subRoot;\n            // Blank out the subtree data\n            for (let i = 0; i < this.subDepth + 1; i += 1) {\n                if (this.hashLength === 2) {\n                    this.leafQueue.levels.get(i)?.set(0, 0n);\n                }\n                else {\n                    const levels = new Map(Object.entries([0n, 0n, 0n, 0n]).map(([key, value]) => [Number(key), value]));\n                    this.leafQueue.levels.set(i, levels);\n                }\n            }\n        }\n        // Update the subtree index\n        this.currentSubtreeIndex += 1;\n        // Update the number of leaves\n        this.numLeaves = this.currentSubtreeIndex * subTreeCapacity;\n        this.subTreesMerged = false;\n        this.smallSRTroot = 0n;\n    }\n    /**\n     * Private function that performs the actual fill operation\n     * @param level - The level of the subtree\n     */\n    fillOp(level) {\n        if (level > this.subDepth) {\n            return;\n        }\n        const n = this.leafQueue.indices[level];\n        if (n !== 0) {\n            // Fill the subtree level and hash it\n            let hashed;\n            if (this.hashLength === 2) {\n                hashed = this.hashFunc([this.leafQueue.levels.get(level)?.get(0) ?? 0n, this.zeros[level]]);\n            }\n            else {\n                for (let i = n; i < this.hashLength; i += 1) {\n                    this.leafQueue.levels.get(level)?.set(i, this.zeros[level]);\n                }\n                const levelSlice = this.leafQueue.levels.get(level) ?? new Map();\n                hashed = this.hashFunc(Array.from(levelSlice.values()));\n            }\n            // Update the subtree from the next level onwards with the new leaf\n            this.enqueueOp(hashed, level + 1);\n            // Reset the current level\n            this.leafQueue.indices[level] = 0;\n        }\n        // Recurse\n        this.fillOp(level + 1);\n    }\n    /**\n     * Calculate the depth of the smallest possible Merkle tree which fits all\n     * @returns the depth of the smallest possible Merkle tree which fits all\n     */\n    calcSRTdepth() {\n        // Calculate the SRT depth\n        let srtDepth = this.subDepth;\n        const subTreeCapacity = this.hashLength ** this.subDepth;\n        while (this.hashLength ** srtDepth < this.subRoots.length * subTreeCapacity) {\n            srtDepth += 1;\n        }\n        return srtDepth;\n    }\n    /**\n     * Insert a subtree into the queue. This is used when the subtree is\n     * already computed.\n     * @param subRoot - The root of the subtree\n     */\n    insertSubTree(subRoot) {\n        // If the current subtree is not full, fill it.\n        const subTreeCapacity = this.hashLength ** this.subDepth;\n        this.subRoots[this.currentSubtreeIndex] = subRoot;\n        // Update the subtree index\n        this.currentSubtreeIndex += 1;\n        // Update the number of leaves\n        this.numLeaves += subTreeCapacity;\n        // Reset the subroot tree root now that it is obsolete\n        this.smallSRTroot = 0n;\n        this.subTreesMerged = false;\n    }\n    /**\n     * Merge all the subroots into a tree of a specified depth.\n     * It requires this.mergeSubRoots() to be run first.\n     */\n    merge(depth) {\n        (0, assert_1.default)(this.subTreesMerged);\n        (0, assert_1.default)(depth <= this.MAX_DEPTH);\n        const srtDepth = this.calcSRTdepth();\n        (0, assert_1.default)(depth >= srtDepth);\n        if (depth === srtDepth) {\n            this.mainRoots[depth] = this.smallSRTroot;\n        }\n        else {\n            let root = this.smallSRTroot;\n            // Calculate the main root\n            for (let i = srtDepth; i < depth; i += 1) {\n                const inputs = [root];\n                const z = this.zeros[i];\n                for (let j = 1; j < this.hashLength; j += 1) {\n                    inputs.push(z);\n                }\n                root = this.hashFunc(inputs);\n            }\n            this.mainRoots[depth] = root;\n        }\n    }\n    /**\n     * Merge all the subroots into a tree of a specified depth.\n     * Uses an IncrementalQuinTree instead of the two-step method that\n     * AccQueue.sol uses.\n     */\n    mergeDirect(depth) {\n        // There must be subtrees to merge\n        (0, assert_1.default)(this.numLeaves > 0);\n        const srtDepth = this.calcSRTdepth();\n        // The desired tree must be deep enough\n        (0, assert_1.default)(depth >= srtDepth);\n        if (depth === this.subDepth) {\n            // If there is only 1 subtree, and the desired depth is the subtree\n            // depth, the subroot is the result\n            (0, assert_1.default)(this.numLeaves === this.hashLength ** this.subDepth);\n            const [subRoot] = this.subRoots;\n            this.mainRoots[depth] = subRoot;\n            this.subTreesMerged = true;\n            return;\n        }\n        // The desired main tree must be deep enough to fit all leaves\n        (0, assert_1.default)(BigInt(depth ** this.hashLength) >= this.numLeaves);\n        // Fill any empty leaves in the last subtree with zeros\n        if (this.numLeaves % this.hashLength ** this.subDepth > 0) {\n            this.fill();\n        }\n        const tree = new quinTree_1.IncrementalQuinTree(depth - this.subDepth, this.zeros[this.subDepth], this.hashLength, this.hashFunc);\n        this.subRoots.forEach((subRoot) => {\n            tree.insert(subRoot);\n        });\n        this.mainRoots[depth] = tree.root;\n    }\n    /**\n     * Merge all subroots into the smallest possible Merkle tree which fits\n     * them. e.g. if there are 5 subroots and hashLength == 2, the tree depth\n     * is 3 since 2 ** 3 = 8 which is the next power of 2.\n     * @param numSrQueueOps - The number of subroots to queue into the SRT\n     */\n    mergeSubRoots(numSrQueueOps = 0) {\n        // This function can only be called once unless a new subtree is created\n        (0, assert_1.default)(!this.subTreesMerged);\n        // There must be subtrees to merge\n        (0, assert_1.default)(this.numLeaves > 0);\n        // Fill any empty leaves in the last subtree with zeros\n        if (this.numLeaves % this.hashLength ** this.subDepth !== 0) {\n            this.fill();\n        }\n        // If there is only 1 subtree, use its root\n        if (this.currentSubtreeIndex === 1) {\n            this.smallSRTroot = this.getSubRoot(0);\n            this.subTreesMerged = true;\n            return;\n        }\n        // Compute the depth and maximum capacity of the smallMainTreeRoot\n        const depth = (0, utils_1.calcDepthFromNumLeaves)(this.hashLength, this.currentSubtreeIndex);\n        let numQueueOps = 0;\n        for (let i = this.nextSRindexToQueue; i < this.currentSubtreeIndex; i += 1) {\n            // Stop if the limit has been reached\n            if (numSrQueueOps !== 0 && numQueueOps === numSrQueueOps) {\n                return;\n            }\n            // Queue the next subroot\n            const subRoot = this.getSubRoot(this.nextSRindexToQueue);\n            this.queueSubRoot(subRoot, 0, depth);\n            // Increment the next subroot counter\n            this.nextSRindexToQueue += 1;\n            numQueueOps += 1;\n        }\n        // Queue zeros to get the SRT. `m` is the number of leaves in the\n        // main tree, which already has `this.currentSubtreeIndex` leaves\n        const m = this.hashLength ** depth;\n        if (this.nextSRindexToQueue === this.currentSubtreeIndex) {\n            for (let i = this.currentSubtreeIndex; i < m; i += 1) {\n                const z = this.zeros[this.subDepth];\n                this.queueSubRoot(z, 0, depth);\n            }\n        }\n        // Store the root\n        const subRoot = this.subRootQueue.levels.get(depth)?.get(0) ?? 0n;\n        this.smallSRTroot = subRoot;\n        this.subTreesMerged = true;\n    }\n    /**\n     * Queues the leaf (a subroot) into queuedSRTlevels\n     * @param leaf - The leaf to insert\n     * @param level - The level of the subtree\n     * @param maxDepth - The maximum depth of the tree\n     */\n    queueSubRoot(leaf, level, maxDepth) {\n        if (level > maxDepth) {\n            return;\n        }\n        const n = this.subRootQueue.indices[level];\n        if (n !== this.hashLength - 1) {\n            // Just store the leaf\n            this.subRootQueue.levels.get(level)?.set(n, leaf);\n            this.subRootQueue.indices[level] += 1;\n        }\n        else {\n            // Hash the elements in this level and queue it in the next level\n            const inputs = [];\n            for (let i = 0; i < this.hashLength - 1; i += 1) {\n                inputs.push(this.subRootQueue.levels.get(level)?.get(i) ?? 0n);\n            }\n            inputs.push(leaf);\n            const hashed = this.hashFunc(inputs);\n            // Recurse\n            this.subRootQueue.indices[level] = 0;\n            this.queueSubRoot(hashed, level + 1, maxDepth);\n        }\n    }\n    /**\n     * Get the root at a certain depth\n     * @param depth - The depth of the tree\n     * @returns the root\n     */\n    getRoot(depth) {\n        return this.mainRoots[depth];\n    }\n    /**\n     * Check if the root at a certain depth exists (subtree root)\n     * @param depth - the depth of the tree\n     * @returns whether the root exists\n     */\n    hasRoot(depth) {\n        const root = this.getRoot(depth);\n        return !(root === null || root === undefined);\n    }\n    /**\n     * @notice Deep-copies this object\n     * @returns a deep copy of this object\n     */\n    copy() {\n        const newAccQueue = new AccQueue(this.subDepth, this.hashLength, this.zeroValue);\n        newAccQueue.currentSubtreeIndex = JSON.parse(JSON.stringify(this.currentSubtreeIndex));\n        newAccQueue.numLeaves = JSON.parse(JSON.stringify(this.numLeaves));\n        const arrayLeafLevels = (0, bigIntUtils_1.unstringifyBigInts)(JSON.parse(JSON.stringify((0, bigIntUtils_1.stringifyBigInts)(this.mapToArray(this.leafQueue.levels)))));\n        newAccQueue.leafQueue.levels = this.arrayToMap(arrayLeafLevels);\n        newAccQueue.leafQueue.indices = JSON.parse(JSON.stringify(this.leafQueue.indices));\n        newAccQueue.subRoots = (0, bigIntUtils_1.deepCopyBigIntArray)(this.subRoots);\n        newAccQueue.mainRoots = (0, bigIntUtils_1.deepCopyBigIntArray)(this.mainRoots);\n        newAccQueue.zeros = (0, bigIntUtils_1.deepCopyBigIntArray)(this.zeros);\n        newAccQueue.subTreesMerged = !!this.subTreesMerged;\n        newAccQueue.nextSRindexToQueue = Number(this.nextSRindexToQueue.toString());\n        newAccQueue.smallSRTroot = BigInt(this.smallSRTroot.toString());\n        newAccQueue.subRootQueue.indices = JSON.parse(JSON.stringify(this.subRootQueue.indices));\n        const arraySubRootLevels = (0, bigIntUtils_1.unstringifyBigInts)(JSON.parse(JSON.stringify((0, bigIntUtils_1.stringifyBigInts)(this.mapToArray(this.subRootQueue.levels)))));\n        newAccQueue.subRootQueue.levels = this.arrayToMap(arraySubRootLevels);\n        return newAccQueue;\n    }\n    /**\n     * Convert map to 2D array\n     *\n     * @param map - map representation of 2D array\n     * @returns 2D array\n     */\n    mapToArray(map) {\n        return Array.from(map.values()).map((v) => Array.from(v.values()));\n    }\n    /**\n     * Convert 2D array to its map representation\n     *\n     * @param array - 2D array\n     * @returns map representation of 2D array\n     */\n    arrayToMap(array) {\n        return new Map(array.map((level, i) => [i, new Map(level.map((leaf, j) => [j, leaf]))]));\n    }\n    /**\n     * Hash an array of leaves\n     * @param leaves - The leaves to hash\n     * @returns the hash value of the leaves\n     */\n    hash(leaves) {\n        (0, assert_1.default)(leaves.length === this.hashLength);\n        return this.hashFunc(leaves);\n    }\n}\nexports.AccQueue = AccQueue;\n//# sourceMappingURL=AccQueue.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFjaS1jcnlwdG8vYnVpbGQvdHMvQWNjUXVldWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsaUNBQWlDLG1CQUFPLENBQUMsc0JBQVE7QUFDakQsc0JBQXNCLG1CQUFPLENBQUMsK0VBQWU7QUFDN0Msa0JBQWtCLG1CQUFPLENBQUMsdUVBQVc7QUFDckMsbUJBQW1CLG1CQUFPLENBQUMseUVBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsV0FBVztBQUM5QztBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw4QkFBOEI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9tYWNpLWNyeXB0by9idWlsZC90cy9BY2NRdWV1ZS5qcz8zODdhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BY2NRdWV1ZSA9IHZvaWQgMDtcbmNvbnN0IGFzc2VydF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuY29uc3QgYmlnSW50VXRpbHNfMSA9IHJlcXVpcmUoXCIuL2JpZ0ludFV0aWxzXCIpO1xuY29uc3QgaGFzaGluZ18xID0gcmVxdWlyZShcIi4vaGFzaGluZ1wiKTtcbmNvbnN0IHF1aW5UcmVlXzEgPSByZXF1aXJlKFwiLi9xdWluVHJlZVwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogQW4gQWNjdW11bGF0b3IgUXVldWUgd2hpY2ggY29uZm9ybXMgdG8gdGhlIGltcGxlbWVudGF0aW9uIGluIEFjY1F1ZXVlLnNvbC5cbiAqIEVhY2ggZW5xdWV1ZSgpIG9wZXJhdGlvbiB1cGRhdGVzIGEgc3VidHJlZSwgYW5kIGEgbWVyZ2UoKSBvcGVyYXRpb24gY29tYmluZXNcbiAqIGFsbCBzdWJ0cmVlcyBpbnRvIGEgbWFpbiB0cmVlLlxuICogQG5vdGljZSBJdCBzdXBwb3J0cyAyIG9yIDUgZWxlbWVudHMgcGVyIGxlYWYuXG4gKi9cbmNsYXNzIEFjY1F1ZXVlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQWNjUXVldWVcbiAgICAgKiBAcGFyYW0gc3ViRGVwdGggLSB0aGUgZGVwdGggb2YgdGhlIHN1YnRyZWVzXG4gICAgICogQHBhcmFtIGhhc2hMZW5ndGggLSB0aGUgbnVtYmVyIG9mIGxlYXZlcyBwZXIgbm9kZVxuICAgICAqIEBwYXJhbSB6ZXJvVmFsdWUgLSB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgZW1wdHkgbGVhdmVzXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3ViRGVwdGgsIGhhc2hMZW5ndGgsIHplcm9WYWx1ZSkge1xuICAgICAgICAvLyBUaGlzIGNsYXNzIHN1cHBvcnRzIGVpdGhlciAyIGxlYXZlcyBwZXIgbm9kZSwgb3IgNSBsZWF2ZXMgcGVyIG5vZGUuXG4gICAgICAgIC8vIDUgaXMgbGFyZ2VzdCBudW1iZXIgb2YgaW5wdXRzIHdoaWNoIGNpcmNvbWxpYidzIFBvc2VpZG9uIEVWTSBoYXNoXG4gICAgICAgIC8vIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uIHN1cHBvcnRzLlxuICAgICAgICB0aGlzLk1BWF9ERVBUSCA9IDMyO1xuICAgICAgICAvLyBUaGUgY3VycmVudCBzdWJ0cmVlIGluZGV4LiBlLmcuIHRoZSBmaXJzdCBzdWJ0cmVlIGhhcyBpbmRleCAwLCB0aGVcbiAgICAgICAgLy8gc2Vjb25kIGhhcyAxLCBhbmQgc28gb25cbiAgICAgICAgdGhpcy5jdXJyZW50U3VidHJlZUluZGV4ID0gMDtcbiAgICAgICAgLy8gVGhlIG51bWJlciBvZiBsZWF2ZXMgYWNyb3NzIGFsbCBzdWJ0cmVlc1xuICAgICAgICB0aGlzLm51bUxlYXZlcyA9IDA7XG4gICAgICAgIC8vIFRoZSBjdXJyZW50IHN1YnRyZWVcbiAgICAgICAgdGhpcy5sZWFmUXVldWUgPSB7XG4gICAgICAgICAgICBsZXZlbHM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGluZGljZXM6IFtdLFxuICAgICAgICB9O1xuICAgICAgICAvLyBGb3IgbWVyZ2luZyBzdWJ0cmVlcyBpbnRvIHRoZSBzbWFsbGVzdCB0cmVlXG4gICAgICAgIHRoaXMubmV4dFNSaW5kZXhUb1F1ZXVlID0gMDtcbiAgICAgICAgdGhpcy5zbWFsbFNSVHJvb3QgPSAwbjtcbiAgICAgICAgdGhpcy5zdWJSb290UXVldWUgPSB7XG4gICAgICAgICAgICBsZXZlbHM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGluZGljZXM6IFtdLFxuICAgICAgICB9O1xuICAgICAgICAvLyBUaGUgcm9vdCBvZiBlYWNoIGNvbXBsZXRlIHN1YnRyZWVcbiAgICAgICAgdGhpcy5zdWJSb290cyA9IFtdO1xuICAgICAgICAvLyBUaGUgcm9vdCBvZiBtZXJnZWQgc3VidHJlZXNcbiAgICAgICAgdGhpcy5tYWluUm9vdHMgPSBbXTtcbiAgICAgICAgLy8gVGhlIHplcm8gdmFsdWUgcGVyIGxldmVsLiBpLmUuIHplcm9zWzBdIGlzIHplcm9WYWx1ZSxcbiAgICAgICAgLy8gemVyb3NbMV0gaXMgdGhlIGhhc2ggb2YgbGVhdmVzUGVyTm9kZSB6ZXJvcywgYW5kIHNvIG9uLlxuICAgICAgICB0aGlzLnplcm9zID0gW107XG4gICAgICAgIC8vIFdoZXRoZXIgdGhlIHN1YnRyZWVzIGhhdmUgYmVlbiBtZXJnZWRcbiAgICAgICAgdGhpcy5zdWJUcmVlc01lcmdlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJpdmF0ZSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIHRoZSBhY3R1YWwgZW5xdWV1ZSBvcGVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIGxlYWYgLSBUaGUgbGVhZiB0byBpbnNlcnRcbiAgICAgICAgICogQHBhcmFtIGxldmVsIC0gVGhlIGxldmVsIG9mIHRoZSBzdWJ0cmVlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVucXVldWVPcCA9IChsZWFmLCBsZXZlbCkgPT4ge1xuICAgICAgICAgICAgLy8gc21hbGwgdmFsaWRhdGlvbiwgZG8gbm8gdGhyb3dcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IHRoaXMuc3ViRGVwdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBnZXQgdGhlIGluZGV4IHRvIGRldGVybWluZSB3aGVyZSB0byBpbnNlcnQgdGhlIG5leHQgbGVhZlxuICAgICAgICAgICAgY29uc3QgbiA9IHRoaXMubGVhZlF1ZXVlLmluZGljZXNbbGV2ZWxdO1xuICAgICAgICAgICAgLy8gd2UgY2hlY2sgdGhhdCB0aGUgaW5kZXggaXMgbm90IHRoZSBsYXN0IG9uZSAoMSBvciA0IGRlcGVuZGluZyBvbiB0aGUgaGFzaCBsZW5ndGgpXG4gICAgICAgICAgICBpZiAobiAhPT0gdGhpcy5oYXNoTGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIC8vIEp1c3Qgc3RvcmUgdGhlIGxlYWZcbiAgICAgICAgICAgICAgICB0aGlzLmxlYWZRdWV1ZS5sZXZlbHMuZ2V0KGxldmVsKT8uc2V0KG4sIGxlYWYpO1xuICAgICAgICAgICAgICAgIHRoaXMubGVhZlF1ZXVlLmluZGljZXNbbGV2ZWxdICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBub3Qgd2UgY29tcHV0ZSB0aGUgcm9vdFxuICAgICAgICAgICAgICAgIGxldCBoYXNoZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzaExlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJSb290ID0gdGhpcy5sZWFmUXVldWUubGV2ZWxzLmdldChsZXZlbCk/LmdldCgwKSA/PyAwbjtcbiAgICAgICAgICAgICAgICAgICAgaGFzaGVkID0gdGhpcy5oYXNoRnVuYyhbc3ViUm9vdCwgbGVhZl0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlYWZRdWV1ZS5sZXZlbHMuZ2V0KGxldmVsKT8uc2V0KDAsIDBuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxldmVsU2xpY2UgPSB0aGlzLmxlYWZRdWV1ZS5sZXZlbHMuZ2V0KGxldmVsKSA/PyBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgIGhhc2hlZCA9IHRoaXMuaGFzaEZ1bmMoQXJyYXkuZnJvbShsZXZlbFNsaWNlLnZhbHVlcygpKS5jb25jYXQobGVhZikpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWFmUXVldWUubGV2ZWxzLmdldChsZXZlbCk/LnNldChpLCAwbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5sZWFmUXVldWUuaW5kaWNlc1tsZXZlbF0gPSAwO1xuICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2VcbiAgICAgICAgICAgICAgICB0aGlzLmVucXVldWVPcChoYXNoZWQsIGxldmVsICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShoYXNoTGVuZ3RoID09PSAyIHx8IGhhc2hMZW5ndGggPT09IDUpO1xuICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoc3ViRGVwdGggPiAwKTtcbiAgICAgICAgdGhpcy5oYXNoTGVuZ3RoID0gaGFzaExlbmd0aDtcbiAgICAgICAgdGhpcy5zdWJEZXB0aCA9IHN1YkRlcHRoO1xuICAgICAgICB0aGlzLnplcm9WYWx1ZSA9IHplcm9WYWx1ZTtcbiAgICAgICAgLy8gU2V0IHRoaXMuaGFzaEZ1bmMgZGVwZW5kaW5nIG9uIHRoZSBudW1iZXIgb2YgbGVhdmVzIHBlciBub2RlXG4gICAgICAgIGlmICh0aGlzLmhhc2hMZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIC8vIFVzZXMgUG9zZWlkb25UMyB1bmRlciB0aGUgaG9vZCwgd2hpY2ggYWNjZXB0cyAyIGlucHV0c1xuICAgICAgICAgICAgdGhpcy5oYXNoRnVuYyA9IChpbnB1dHMpID0+ICgwLCBoYXNoaW5nXzEuaGFzaExlZnRSaWdodCkoaW5wdXRzWzBdLCBpbnB1dHNbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVXNlcyBQb3NlaWRvblQ2IHVuZGVyIHRoZSBob29kLCB3aGljaCBhY2NlcHRzIHVwIHRvIDUgaW5wdXRzXG4gICAgICAgICAgICB0aGlzLmhhc2hGdW5jID0gaGFzaGluZ18xLmhhc2g1O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3ViSGFzaEZ1bmMgPSBoYXNoaW5nXzEuc2hhMjU2SGFzaDtcbiAgICAgICAgbGV0IGhhc2hlZCA9IHRoaXMuemVyb1ZhbHVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuTUFYX0RFUFRIOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHRoaXMuemVyb3MucHVzaChoYXNoZWQpO1xuICAgICAgICAgICAgbGV0IGUgPSBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc2hMZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICBlID0gWzBuXTtcbiAgICAgICAgICAgICAgICBoYXNoZWQgPSB0aGlzLmhhc2hGdW5jKFtoYXNoZWQsIGhhc2hlZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZSA9IFswbiwgMG4sIDBuLCAwbl07XG4gICAgICAgICAgICAgICAgaGFzaGVkID0gdGhpcy5oYXNoRnVuYyhbaGFzaGVkLCBoYXNoZWQsIGhhc2hlZCwgaGFzaGVkLCBoYXNoZWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxldmVscyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoZSkubWFwKChba2V5LCB2YWx1ZV0pID0+IFtOdW1iZXIoa2V5KSwgdmFsdWVdKSk7XG4gICAgICAgICAgICB0aGlzLmxlYWZRdWV1ZS5sZXZlbHMuc2V0KHRoaXMubGVhZlF1ZXVlLmxldmVscy5zaXplLCBsZXZlbHMpO1xuICAgICAgICAgICAgdGhpcy5sZWFmUXVldWUuaW5kaWNlc1tpXSA9IDA7XG4gICAgICAgICAgICB0aGlzLnN1YlJvb3RRdWV1ZS5sZXZlbHMuc2V0KHRoaXMuc3ViUm9vdFF1ZXVlLmxldmVscy5zaXplLCBsZXZlbHMpO1xuICAgICAgICAgICAgdGhpcy5zdWJSb290UXVldWUuaW5kaWNlc1tpXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzbWFsbCBTUlQgcm9vdFxuICAgICAqIEByZXR1cm5zIHNtYWxsIFNSVCByb290XG4gICAgICovXG4gICAgZ2V0U21hbGxTUlRyb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbWFsbFNSVHJvb3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3Vicm9vdHNcbiAgICAgKiBAcmV0dXJucyBzdWJyb290c1xuICAgICAqL1xuICAgIGdldFN1YlJvb3RzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJSb290cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdWJkZXB0aFxuICAgICAqIEByZXR1cm5zIHN1YmRlcHRoXG4gICAgICovXG4gICAgZ2V0U3ViRGVwdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YkRlcHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJvb3Qgb2YgbWVyZ2VkIHN1YnRyZWVzXG4gICAgICogQHJldHVybnMgdGhlIHJvb3Qgb2YgbWVyZ2VkIHN1YnRyZWVzXG4gICAgICovXG4gICAgZ2V0TWFpblJvb3RzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYWluUm9vdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgemVybyB2YWx1ZXMgcGVyIGxldmVsLiBpLmUuIHplcm9zWzBdIGlzIHplcm9WYWx1ZSxcbiAgICAgKiB6ZXJvc1sxXSBpcyB0aGUgaGFzaCBvZiBsZWF2ZXNQZXJOb2RlIHplcm9zLCBhbmQgc28gb24uXG4gICAgICogQHJldHVybnMgemVyb3NcbiAgICAgKi9cbiAgICBnZXRaZXJvcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuemVyb3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3Vicm9vdCBhdCBhIGdpdmVuIGluZGV4XG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBzdWJyb290XG4gICAgICogQHJldHVybnMgdGhlIHN1YnJvb3RcbiAgICAgKi9cbiAgICBnZXRTdWJSb290KGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YlJvb3RzW2luZGV4XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgaW5wdXRzIHBlciBoYXNoIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgbnVtYmVyIG9mIGlucHV0c1xuICAgICAqL1xuICAgIGdldEhhc2hMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc2hMZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVucXVldWUgYSBsZWFmIGludG8gdGhlIGN1cnJlbnQgc3VidHJlZVxuICAgICAqIEBwYXJhbSBsZWFmIFRoZSBsZWFmIHRvIGluc2VydC5cbiAgICAgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIGxlYWZcbiAgICAgKi9cbiAgICBlbnF1ZXVlKGxlYWYpIHtcbiAgICAgICAgLy8gdmFsaWRhdGlvblxuICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkodGhpcy5udW1MZWF2ZXMgPCB0aGlzLmhhc2hMZW5ndGggKiogdGhpcy5NQVhfREVQVEgsIFwiQWNjUXVldWUgaXMgZnVsbFwiKTtcbiAgICAgICAgdGhpcy5lbnF1ZXVlT3AobGVhZiwgMCk7XG4gICAgICAgIC8vIHRoZSBpbmRleCBpcyB0aGUgbnVtYmVyIG9mIGxlYXZlcyAoMC1pbmRleClcbiAgICAgICAgY29uc3QgbGVhZkluZGV4ID0gdGhpcy5udW1MZWF2ZXM7XG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBudW1iZXIgb2YgbGVhdmVzXG4gICAgICAgIHRoaXMubnVtTGVhdmVzICs9IDE7XG4gICAgICAgIC8vIHdlIHNldCBtZXJnZWQgZmFsc2UgYmVjYXVzZSB0aGVyZSBhcmUgbmV3IGxlYXZlc1xuICAgICAgICB0aGlzLnN1YlRyZWVzTWVyZ2VkID0gZmFsc2U7XG4gICAgICAgIC8vIHJlc2V0IHRoZSBzbWFsbFNSVHJvb3QgYmVjYXVzZSBpdCBpcyBvYnNvbGV0ZVxuICAgICAgICB0aGlzLnNtYWxsU1JUcm9vdCA9IDBuO1xuICAgICAgICAvLyBAdG9kbyB0aGlzIGNhbiBiZSBtb3ZlZCBpbiB0aGUgY29uc3RydWN0b3IgcmF0aGVyIHRoYW4gY29tcHV0aW5nIGV2ZXJ5IHRpbWVcbiAgICAgICAgY29uc3Qgc3ViVHJlZUNhcGFjaXR5ID0gdGhpcy5oYXNoTGVuZ3RoICoqIHRoaXMuc3ViRGVwdGg7XG4gICAgICAgIC8vIElmIHRoZSBjdXJyZW50IHN1YnRyZWUgaXMgZnVsbFxuICAgICAgICBpZiAodGhpcy5udW1MZWF2ZXMgJSBzdWJUcmVlQ2FwYWNpdHkgPT09IDApIHtcbiAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBzdWJyb290XG4gICAgICAgICAgICBjb25zdCBzdWJSb290ID0gdGhpcy5sZWFmUXVldWUubGV2ZWxzLmdldCh0aGlzLnN1YkRlcHRoKT8uZ2V0KDApID8/IDBuO1xuICAgICAgICAgICAgdGhpcy5zdWJSb290c1t0aGlzLmN1cnJlbnRTdWJ0cmVlSW5kZXhdID0gc3ViUm9vdDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFN1YnRyZWVJbmRleCArPSAxO1xuICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGN1cnJlbnQgc3VidHJlZVxuICAgICAgICAgICAgdGhpcy5sZWFmUXVldWUubGV2ZWxzLmdldCh0aGlzLnN1YkRlcHRoKT8uc2V0KDAsIDBuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5NQVhfREVQVEg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhZlF1ZXVlLmluZGljZXNbaV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWFmSW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbGwgYW55IGVtcHR5IGxlYXZlcyBvZiB0aGUgbGFzdCBzdWJ0cmVlIHdpdGggemVyb3MgYW5kIHN0b3JlIHRoZVxuICAgICAqIHJlc3VsdGluZyBzdWJyb290LlxuICAgICAqL1xuICAgIGZpbGwoKSB7XG4gICAgICAgIC8vIFRoZSB0b3RhbCBjYXBhY2l0eSBvZiB0aGUgc3VidHJlZVxuICAgICAgICBjb25zdCBzdWJUcmVlQ2FwYWNpdHkgPSB0aGlzLmhhc2hMZW5ndGggKiogdGhpcy5zdWJEZXB0aDtcbiAgICAgICAgaWYgKHRoaXMubnVtTGVhdmVzICUgc3ViVHJlZUNhcGFjaXR5ID09PSAwKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc3VidHJlZSBpcyBjb21wbGV0ZWx5IGVtcHR5LCB0aGVuIHRoZSBzdWJyb290IGlzIGFcbiAgICAgICAgICAgIC8vIHByZWNhbGN1bGF0ZWQgemVybyB2YWx1ZVxuICAgICAgICAgICAgdGhpcy5zdWJSb290c1t0aGlzLmN1cnJlbnRTdWJ0cmVlSW5kZXhdID0gdGhpcy56ZXJvc1t0aGlzLnN1YkRlcHRoXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmlsbE9wKDApO1xuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIHN1YnJvb3RcbiAgICAgICAgICAgIGNvbnN0IHN1YlJvb3QgPSB0aGlzLmxlYWZRdWV1ZS5sZXZlbHMuZ2V0KHRoaXMuc3ViRGVwdGgpPy5nZXQoMCkgPz8gMG47XG4gICAgICAgICAgICB0aGlzLnN1YlJvb3RzW3RoaXMuY3VycmVudFN1YnRyZWVJbmRleF0gPSBzdWJSb290O1xuICAgICAgICAgICAgLy8gQmxhbmsgb3V0IHRoZSBzdWJ0cmVlIGRhdGFcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJEZXB0aCArIDE7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc2hMZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWFmUXVldWUubGV2ZWxzLmdldChpKT8uc2V0KDAsIDBuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxldmVscyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoWzBuLCAwbiwgMG4sIDBuXSkubWFwKChba2V5LCB2YWx1ZV0pID0+IFtOdW1iZXIoa2V5KSwgdmFsdWVdKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVhZlF1ZXVlLmxldmVscy5zZXQoaSwgbGV2ZWxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzdWJ0cmVlIGluZGV4XG4gICAgICAgIHRoaXMuY3VycmVudFN1YnRyZWVJbmRleCArPSAxO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIG51bWJlciBvZiBsZWF2ZXNcbiAgICAgICAgdGhpcy5udW1MZWF2ZXMgPSB0aGlzLmN1cnJlbnRTdWJ0cmVlSW5kZXggKiBzdWJUcmVlQ2FwYWNpdHk7XG4gICAgICAgIHRoaXMuc3ViVHJlZXNNZXJnZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zbWFsbFNSVHJvb3QgPSAwbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIHRoZSBhY3R1YWwgZmlsbCBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gbGV2ZWwgLSBUaGUgbGV2ZWwgb2YgdGhlIHN1YnRyZWVcbiAgICAgKi9cbiAgICBmaWxsT3AobGV2ZWwpIHtcbiAgICAgICAgaWYgKGxldmVsID4gdGhpcy5zdWJEZXB0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLmxlYWZRdWV1ZS5pbmRpY2VzW2xldmVsXTtcbiAgICAgICAgaWYgKG4gIT09IDApIHtcbiAgICAgICAgICAgIC8vIEZpbGwgdGhlIHN1YnRyZWUgbGV2ZWwgYW5kIGhhc2ggaXRcbiAgICAgICAgICAgIGxldCBoYXNoZWQ7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNoTGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgaGFzaGVkID0gdGhpcy5oYXNoRnVuYyhbdGhpcy5sZWFmUXVldWUubGV2ZWxzLmdldChsZXZlbCk/LmdldCgwKSA/PyAwbiwgdGhpcy56ZXJvc1tsZXZlbF1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBuOyBpIDwgdGhpcy5oYXNoTGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWFmUXVldWUubGV2ZWxzLmdldChsZXZlbCk/LnNldChpLCB0aGlzLnplcm9zW2xldmVsXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxldmVsU2xpY2UgPSB0aGlzLmxlYWZRdWV1ZS5sZXZlbHMuZ2V0KGxldmVsKSA/PyBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgaGFzaGVkID0gdGhpcy5oYXNoRnVuYyhBcnJheS5mcm9tKGxldmVsU2xpY2UudmFsdWVzKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgc3VidHJlZSBmcm9tIHRoZSBuZXh0IGxldmVsIG9ud2FyZHMgd2l0aCB0aGUgbmV3IGxlYWZcbiAgICAgICAgICAgIHRoaXMuZW5xdWV1ZU9wKGhhc2hlZCwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBjdXJyZW50IGxldmVsXG4gICAgICAgICAgICB0aGlzLmxlYWZRdWV1ZS5pbmRpY2VzW2xldmVsXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzZVxuICAgICAgICB0aGlzLmZpbGxPcChsZXZlbCArIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGRlcHRoIG9mIHRoZSBzbWFsbGVzdCBwb3NzaWJsZSBNZXJrbGUgdHJlZSB3aGljaCBmaXRzIGFsbFxuICAgICAqIEByZXR1cm5zIHRoZSBkZXB0aCBvZiB0aGUgc21hbGxlc3QgcG9zc2libGUgTWVya2xlIHRyZWUgd2hpY2ggZml0cyBhbGxcbiAgICAgKi9cbiAgICBjYWxjU1JUZGVwdGgoKSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgU1JUIGRlcHRoXG4gICAgICAgIGxldCBzcnREZXB0aCA9IHRoaXMuc3ViRGVwdGg7XG4gICAgICAgIGNvbnN0IHN1YlRyZWVDYXBhY2l0eSA9IHRoaXMuaGFzaExlbmd0aCAqKiB0aGlzLnN1YkRlcHRoO1xuICAgICAgICB3aGlsZSAodGhpcy5oYXNoTGVuZ3RoICoqIHNydERlcHRoIDwgdGhpcy5zdWJSb290cy5sZW5ndGggKiBzdWJUcmVlQ2FwYWNpdHkpIHtcbiAgICAgICAgICAgIHNydERlcHRoICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNydERlcHRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYSBzdWJ0cmVlIGludG8gdGhlIHF1ZXVlLiBUaGlzIGlzIHVzZWQgd2hlbiB0aGUgc3VidHJlZSBpc1xuICAgICAqIGFscmVhZHkgY29tcHV0ZWQuXG4gICAgICogQHBhcmFtIHN1YlJvb3QgLSBUaGUgcm9vdCBvZiB0aGUgc3VidHJlZVxuICAgICAqL1xuICAgIGluc2VydFN1YlRyZWUoc3ViUm9vdCkge1xuICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBzdWJ0cmVlIGlzIG5vdCBmdWxsLCBmaWxsIGl0LlxuICAgICAgICBjb25zdCBzdWJUcmVlQ2FwYWNpdHkgPSB0aGlzLmhhc2hMZW5ndGggKiogdGhpcy5zdWJEZXB0aDtcbiAgICAgICAgdGhpcy5zdWJSb290c1t0aGlzLmN1cnJlbnRTdWJ0cmVlSW5kZXhdID0gc3ViUm9vdDtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzdWJ0cmVlIGluZGV4XG4gICAgICAgIHRoaXMuY3VycmVudFN1YnRyZWVJbmRleCArPSAxO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIG51bWJlciBvZiBsZWF2ZXNcbiAgICAgICAgdGhpcy5udW1MZWF2ZXMgKz0gc3ViVHJlZUNhcGFjaXR5O1xuICAgICAgICAvLyBSZXNldCB0aGUgc3Vicm9vdCB0cmVlIHJvb3Qgbm93IHRoYXQgaXQgaXMgb2Jzb2xldGVcbiAgICAgICAgdGhpcy5zbWFsbFNSVHJvb3QgPSAwbjtcbiAgICAgICAgdGhpcy5zdWJUcmVlc01lcmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXJnZSBhbGwgdGhlIHN1YnJvb3RzIGludG8gYSB0cmVlIG9mIGEgc3BlY2lmaWVkIGRlcHRoLlxuICAgICAqIEl0IHJlcXVpcmVzIHRoaXMubWVyZ2VTdWJSb290cygpIHRvIGJlIHJ1biBmaXJzdC5cbiAgICAgKi9cbiAgICBtZXJnZShkZXB0aCkge1xuICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkodGhpcy5zdWJUcmVlc01lcmdlZCk7XG4gICAgICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShkZXB0aCA8PSB0aGlzLk1BWF9ERVBUSCk7XG4gICAgICAgIGNvbnN0IHNydERlcHRoID0gdGhpcy5jYWxjU1JUZGVwdGgoKTtcbiAgICAgICAgKDAsIGFzc2VydF8xLmRlZmF1bHQpKGRlcHRoID49IHNydERlcHRoKTtcbiAgICAgICAgaWYgKGRlcHRoID09PSBzcnREZXB0aCkge1xuICAgICAgICAgICAgdGhpcy5tYWluUm9vdHNbZGVwdGhdID0gdGhpcy5zbWFsbFNSVHJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcm9vdCA9IHRoaXMuc21hbGxTUlRyb290O1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBtYWluIHJvb3RcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzcnREZXB0aDsgaSA8IGRlcHRoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBbcm9vdF07XG4gICAgICAgICAgICAgICAgY29uc3QgeiA9IHRoaXMuemVyb3NbaV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCB0aGlzLmhhc2hMZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dHMucHVzaCh6KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcm9vdCA9IHRoaXMuaGFzaEZ1bmMoaW5wdXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWFpblJvb3RzW2RlcHRoXSA9IHJvb3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVyZ2UgYWxsIHRoZSBzdWJyb290cyBpbnRvIGEgdHJlZSBvZiBhIHNwZWNpZmllZCBkZXB0aC5cbiAgICAgKiBVc2VzIGFuIEluY3JlbWVudGFsUXVpblRyZWUgaW5zdGVhZCBvZiB0aGUgdHdvLXN0ZXAgbWV0aG9kIHRoYXRcbiAgICAgKiBBY2NRdWV1ZS5zb2wgdXNlcy5cbiAgICAgKi9cbiAgICBtZXJnZURpcmVjdChkZXB0aCkge1xuICAgICAgICAvLyBUaGVyZSBtdXN0IGJlIHN1YnRyZWVzIHRvIG1lcmdlXG4gICAgICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KSh0aGlzLm51bUxlYXZlcyA+IDApO1xuICAgICAgICBjb25zdCBzcnREZXB0aCA9IHRoaXMuY2FsY1NSVGRlcHRoKCk7XG4gICAgICAgIC8vIFRoZSBkZXNpcmVkIHRyZWUgbXVzdCBiZSBkZWVwIGVub3VnaFxuICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoZGVwdGggPj0gc3J0RGVwdGgpO1xuICAgICAgICBpZiAoZGVwdGggPT09IHRoaXMuc3ViRGVwdGgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG9ubHkgMSBzdWJ0cmVlLCBhbmQgdGhlIGRlc2lyZWQgZGVwdGggaXMgdGhlIHN1YnRyZWVcbiAgICAgICAgICAgIC8vIGRlcHRoLCB0aGUgc3Vicm9vdCBpcyB0aGUgcmVzdWx0XG4gICAgICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkodGhpcy5udW1MZWF2ZXMgPT09IHRoaXMuaGFzaExlbmd0aCAqKiB0aGlzLnN1YkRlcHRoKTtcbiAgICAgICAgICAgIGNvbnN0IFtzdWJSb290XSA9IHRoaXMuc3ViUm9vdHM7XG4gICAgICAgICAgICB0aGlzLm1haW5Sb290c1tkZXB0aF0gPSBzdWJSb290O1xuICAgICAgICAgICAgdGhpcy5zdWJUcmVlc01lcmdlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGRlc2lyZWQgbWFpbiB0cmVlIG11c3QgYmUgZGVlcCBlbm91Z2ggdG8gZml0IGFsbCBsZWF2ZXNcbiAgICAgICAgKDAsIGFzc2VydF8xLmRlZmF1bHQpKEJpZ0ludChkZXB0aCAqKiB0aGlzLmhhc2hMZW5ndGgpID49IHRoaXMubnVtTGVhdmVzKTtcbiAgICAgICAgLy8gRmlsbCBhbnkgZW1wdHkgbGVhdmVzIGluIHRoZSBsYXN0IHN1YnRyZWUgd2l0aCB6ZXJvc1xuICAgICAgICBpZiAodGhpcy5udW1MZWF2ZXMgJSB0aGlzLmhhc2hMZW5ndGggKiogdGhpcy5zdWJEZXB0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZmlsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyZWUgPSBuZXcgcXVpblRyZWVfMS5JbmNyZW1lbnRhbFF1aW5UcmVlKGRlcHRoIC0gdGhpcy5zdWJEZXB0aCwgdGhpcy56ZXJvc1t0aGlzLnN1YkRlcHRoXSwgdGhpcy5oYXNoTGVuZ3RoLCB0aGlzLmhhc2hGdW5jKTtcbiAgICAgICAgdGhpcy5zdWJSb290cy5mb3JFYWNoKChzdWJSb290KSA9PiB7XG4gICAgICAgICAgICB0cmVlLmluc2VydChzdWJSb290KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFpblJvb3RzW2RlcHRoXSA9IHRyZWUucm9vdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVyZ2UgYWxsIHN1YnJvb3RzIGludG8gdGhlIHNtYWxsZXN0IHBvc3NpYmxlIE1lcmtsZSB0cmVlIHdoaWNoIGZpdHNcbiAgICAgKiB0aGVtLiBlLmcuIGlmIHRoZXJlIGFyZSA1IHN1YnJvb3RzIGFuZCBoYXNoTGVuZ3RoID09IDIsIHRoZSB0cmVlIGRlcHRoXG4gICAgICogaXMgMyBzaW5jZSAyICoqIDMgPSA4IHdoaWNoIGlzIHRoZSBuZXh0IHBvd2VyIG9mIDIuXG4gICAgICogQHBhcmFtIG51bVNyUXVldWVPcHMgLSBUaGUgbnVtYmVyIG9mIHN1YnJvb3RzIHRvIHF1ZXVlIGludG8gdGhlIFNSVFxuICAgICAqL1xuICAgIG1lcmdlU3ViUm9vdHMobnVtU3JRdWV1ZU9wcyA9IDApIHtcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgb25jZSB1bmxlc3MgYSBuZXcgc3VidHJlZSBpcyBjcmVhdGVkXG4gICAgICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KSghdGhpcy5zdWJUcmVlc01lcmdlZCk7XG4gICAgICAgIC8vIFRoZXJlIG11c3QgYmUgc3VidHJlZXMgdG8gbWVyZ2VcbiAgICAgICAgKDAsIGFzc2VydF8xLmRlZmF1bHQpKHRoaXMubnVtTGVhdmVzID4gMCk7XG4gICAgICAgIC8vIEZpbGwgYW55IGVtcHR5IGxlYXZlcyBpbiB0aGUgbGFzdCBzdWJ0cmVlIHdpdGggemVyb3NcbiAgICAgICAgaWYgKHRoaXMubnVtTGVhdmVzICUgdGhpcy5oYXNoTGVuZ3RoICoqIHRoaXMuc3ViRGVwdGggIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZmlsbCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG9ubHkgMSBzdWJ0cmVlLCB1c2UgaXRzIHJvb3RcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFN1YnRyZWVJbmRleCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5zbWFsbFNSVHJvb3QgPSB0aGlzLmdldFN1YlJvb3QoMCk7XG4gICAgICAgICAgICB0aGlzLnN1YlRyZWVzTWVyZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBkZXB0aCBhbmQgbWF4aW11bSBjYXBhY2l0eSBvZiB0aGUgc21hbGxNYWluVHJlZVJvb3RcbiAgICAgICAgY29uc3QgZGVwdGggPSAoMCwgdXRpbHNfMS5jYWxjRGVwdGhGcm9tTnVtTGVhdmVzKSh0aGlzLmhhc2hMZW5ndGgsIHRoaXMuY3VycmVudFN1YnRyZWVJbmRleCk7XG4gICAgICAgIGxldCBudW1RdWV1ZU9wcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLm5leHRTUmluZGV4VG9RdWV1ZTsgaSA8IHRoaXMuY3VycmVudFN1YnRyZWVJbmRleDsgaSArPSAxKSB7XG4gICAgICAgICAgICAvLyBTdG9wIGlmIHRoZSBsaW1pdCBoYXMgYmVlbiByZWFjaGVkXG4gICAgICAgICAgICBpZiAobnVtU3JRdWV1ZU9wcyAhPT0gMCAmJiBudW1RdWV1ZU9wcyA9PT0gbnVtU3JRdWV1ZU9wcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFF1ZXVlIHRoZSBuZXh0IHN1YnJvb3RcbiAgICAgICAgICAgIGNvbnN0IHN1YlJvb3QgPSB0aGlzLmdldFN1YlJvb3QodGhpcy5uZXh0U1JpbmRleFRvUXVldWUpO1xuICAgICAgICAgICAgdGhpcy5xdWV1ZVN1YlJvb3Qoc3ViUm9vdCwgMCwgZGVwdGgpO1xuICAgICAgICAgICAgLy8gSW5jcmVtZW50IHRoZSBuZXh0IHN1YnJvb3QgY291bnRlclxuICAgICAgICAgICAgdGhpcy5uZXh0U1JpbmRleFRvUXVldWUgKz0gMTtcbiAgICAgICAgICAgIG51bVF1ZXVlT3BzICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUXVldWUgemVyb3MgdG8gZ2V0IHRoZSBTUlQuIGBtYCBpcyB0aGUgbnVtYmVyIG9mIGxlYXZlcyBpbiB0aGVcbiAgICAgICAgLy8gbWFpbiB0cmVlLCB3aGljaCBhbHJlYWR5IGhhcyBgdGhpcy5jdXJyZW50U3VidHJlZUluZGV4YCBsZWF2ZXNcbiAgICAgICAgY29uc3QgbSA9IHRoaXMuaGFzaExlbmd0aCAqKiBkZXB0aDtcbiAgICAgICAgaWYgKHRoaXMubmV4dFNSaW5kZXhUb1F1ZXVlID09PSB0aGlzLmN1cnJlbnRTdWJ0cmVlSW5kZXgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmN1cnJlbnRTdWJ0cmVlSW5kZXg7IGkgPCBtOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB6ID0gdGhpcy56ZXJvc1t0aGlzLnN1YkRlcHRoXTtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlU3ViUm9vdCh6LCAwLCBkZXB0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmUgdGhlIHJvb3RcbiAgICAgICAgY29uc3Qgc3ViUm9vdCA9IHRoaXMuc3ViUm9vdFF1ZXVlLmxldmVscy5nZXQoZGVwdGgpPy5nZXQoMCkgPz8gMG47XG4gICAgICAgIHRoaXMuc21hbGxTUlRyb290ID0gc3ViUm9vdDtcbiAgICAgICAgdGhpcy5zdWJUcmVlc01lcmdlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXVlcyB0aGUgbGVhZiAoYSBzdWJyb290KSBpbnRvIHF1ZXVlZFNSVGxldmVsc1xuICAgICAqIEBwYXJhbSBsZWFmIC0gVGhlIGxlYWYgdG8gaW5zZXJ0XG4gICAgICogQHBhcmFtIGxldmVsIC0gVGhlIGxldmVsIG9mIHRoZSBzdWJ0cmVlXG4gICAgICogQHBhcmFtIG1heERlcHRoIC0gVGhlIG1heGltdW0gZGVwdGggb2YgdGhlIHRyZWVcbiAgICAgKi9cbiAgICBxdWV1ZVN1YlJvb3QobGVhZiwgbGV2ZWwsIG1heERlcHRoKSB7XG4gICAgICAgIGlmIChsZXZlbCA+IG1heERlcHRoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbiA9IHRoaXMuc3ViUm9vdFF1ZXVlLmluZGljZXNbbGV2ZWxdO1xuICAgICAgICBpZiAobiAhPT0gdGhpcy5oYXNoTGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgLy8gSnVzdCBzdG9yZSB0aGUgbGVhZlxuICAgICAgICAgICAgdGhpcy5zdWJSb290UXVldWUubGV2ZWxzLmdldChsZXZlbCk/LnNldChuLCBsZWFmKTtcbiAgICAgICAgICAgIHRoaXMuc3ViUm9vdFF1ZXVlLmluZGljZXNbbGV2ZWxdICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBIYXNoIHRoZSBlbGVtZW50cyBpbiB0aGlzIGxldmVsIGFuZCBxdWV1ZSBpdCBpbiB0aGUgbmV4dCBsZXZlbFxuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaGFzaExlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlucHV0cy5wdXNoKHRoaXMuc3ViUm9vdFF1ZXVlLmxldmVscy5nZXQobGV2ZWwpPy5nZXQoaSkgPz8gMG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXRzLnB1c2gobGVhZik7XG4gICAgICAgICAgICBjb25zdCBoYXNoZWQgPSB0aGlzLmhhc2hGdW5jKGlucHV0cyk7XG4gICAgICAgICAgICAvLyBSZWN1cnNlXG4gICAgICAgICAgICB0aGlzLnN1YlJvb3RRdWV1ZS5pbmRpY2VzW2xldmVsXSA9IDA7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlU3ViUm9vdChoYXNoZWQsIGxldmVsICsgMSwgbWF4RGVwdGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcm9vdCBhdCBhIGNlcnRhaW4gZGVwdGhcbiAgICAgKiBAcGFyYW0gZGVwdGggLSBUaGUgZGVwdGggb2YgdGhlIHRyZWVcbiAgICAgKiBAcmV0dXJucyB0aGUgcm9vdFxuICAgICAqL1xuICAgIGdldFJvb3QoZGVwdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFpblJvb3RzW2RlcHRoXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHJvb3QgYXQgYSBjZXJ0YWluIGRlcHRoIGV4aXN0cyAoc3VidHJlZSByb290KVxuICAgICAqIEBwYXJhbSBkZXB0aCAtIHRoZSBkZXB0aCBvZiB0aGUgdHJlZVxuICAgICAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIHJvb3QgZXhpc3RzXG4gICAgICovXG4gICAgaGFzUm9vdChkZXB0aCkge1xuICAgICAgICBjb25zdCByb290ID0gdGhpcy5nZXRSb290KGRlcHRoKTtcbiAgICAgICAgcmV0dXJuICEocm9vdCA9PT0gbnVsbCB8fCByb290ID09PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbm90aWNlIERlZXAtY29waWVzIHRoaXMgb2JqZWN0XG4gICAgICogQHJldHVybnMgYSBkZWVwIGNvcHkgb2YgdGhpcyBvYmplY3RcbiAgICAgKi9cbiAgICBjb3B5KCkge1xuICAgICAgICBjb25zdCBuZXdBY2NRdWV1ZSA9IG5ldyBBY2NRdWV1ZSh0aGlzLnN1YkRlcHRoLCB0aGlzLmhhc2hMZW5ndGgsIHRoaXMuemVyb1ZhbHVlKTtcbiAgICAgICAgbmV3QWNjUXVldWUuY3VycmVudFN1YnRyZWVJbmRleCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5jdXJyZW50U3VidHJlZUluZGV4KSk7XG4gICAgICAgIG5ld0FjY1F1ZXVlLm51bUxlYXZlcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5udW1MZWF2ZXMpKTtcbiAgICAgICAgY29uc3QgYXJyYXlMZWFmTGV2ZWxzID0gKDAsIGJpZ0ludFV0aWxzXzEudW5zdHJpbmdpZnlCaWdJbnRzKShKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KCgwLCBiaWdJbnRVdGlsc18xLnN0cmluZ2lmeUJpZ0ludHMpKHRoaXMubWFwVG9BcnJheSh0aGlzLmxlYWZRdWV1ZS5sZXZlbHMpKSkpKTtcbiAgICAgICAgbmV3QWNjUXVldWUubGVhZlF1ZXVlLmxldmVscyA9IHRoaXMuYXJyYXlUb01hcChhcnJheUxlYWZMZXZlbHMpO1xuICAgICAgICBuZXdBY2NRdWV1ZS5sZWFmUXVldWUuaW5kaWNlcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5sZWFmUXVldWUuaW5kaWNlcykpO1xuICAgICAgICBuZXdBY2NRdWV1ZS5zdWJSb290cyA9ICgwLCBiaWdJbnRVdGlsc18xLmRlZXBDb3B5QmlnSW50QXJyYXkpKHRoaXMuc3ViUm9vdHMpO1xuICAgICAgICBuZXdBY2NRdWV1ZS5tYWluUm9vdHMgPSAoMCwgYmlnSW50VXRpbHNfMS5kZWVwQ29weUJpZ0ludEFycmF5KSh0aGlzLm1haW5Sb290cyk7XG4gICAgICAgIG5ld0FjY1F1ZXVlLnplcm9zID0gKDAsIGJpZ0ludFV0aWxzXzEuZGVlcENvcHlCaWdJbnRBcnJheSkodGhpcy56ZXJvcyk7XG4gICAgICAgIG5ld0FjY1F1ZXVlLnN1YlRyZWVzTWVyZ2VkID0gISF0aGlzLnN1YlRyZWVzTWVyZ2VkO1xuICAgICAgICBuZXdBY2NRdWV1ZS5uZXh0U1JpbmRleFRvUXVldWUgPSBOdW1iZXIodGhpcy5uZXh0U1JpbmRleFRvUXVldWUudG9TdHJpbmcoKSk7XG4gICAgICAgIG5ld0FjY1F1ZXVlLnNtYWxsU1JUcm9vdCA9IEJpZ0ludCh0aGlzLnNtYWxsU1JUcm9vdC50b1N0cmluZygpKTtcbiAgICAgICAgbmV3QWNjUXVldWUuc3ViUm9vdFF1ZXVlLmluZGljZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuc3ViUm9vdFF1ZXVlLmluZGljZXMpKTtcbiAgICAgICAgY29uc3QgYXJyYXlTdWJSb290TGV2ZWxzID0gKDAsIGJpZ0ludFV0aWxzXzEudW5zdHJpbmdpZnlCaWdJbnRzKShKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KCgwLCBiaWdJbnRVdGlsc18xLnN0cmluZ2lmeUJpZ0ludHMpKHRoaXMubWFwVG9BcnJheSh0aGlzLnN1YlJvb3RRdWV1ZS5sZXZlbHMpKSkpKTtcbiAgICAgICAgbmV3QWNjUXVldWUuc3ViUm9vdFF1ZXVlLmxldmVscyA9IHRoaXMuYXJyYXlUb01hcChhcnJheVN1YlJvb3RMZXZlbHMpO1xuICAgICAgICByZXR1cm4gbmV3QWNjUXVldWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgbWFwIHRvIDJEIGFycmF5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWFwIC0gbWFwIHJlcHJlc2VudGF0aW9uIG9mIDJEIGFycmF5XG4gICAgICogQHJldHVybnMgMkQgYXJyYXlcbiAgICAgKi9cbiAgICBtYXBUb0FycmF5KG1hcCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShtYXAudmFsdWVzKCkpLm1hcCgodikgPT4gQXJyYXkuZnJvbSh2LnZhbHVlcygpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgMkQgYXJyYXkgdG8gaXRzIG1hcCByZXByZXNlbnRhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIGFycmF5IC0gMkQgYXJyYXlcbiAgICAgKiBAcmV0dXJucyBtYXAgcmVwcmVzZW50YXRpb24gb2YgMkQgYXJyYXlcbiAgICAgKi9cbiAgICBhcnJheVRvTWFwKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKGFycmF5Lm1hcCgobGV2ZWwsIGkpID0+IFtpLCBuZXcgTWFwKGxldmVsLm1hcCgobGVhZiwgaikgPT4gW2osIGxlYWZdKSldKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhc2ggYW4gYXJyYXkgb2YgbGVhdmVzXG4gICAgICogQHBhcmFtIGxlYXZlcyAtIFRoZSBsZWF2ZXMgdG8gaGFzaFxuICAgICAqIEByZXR1cm5zIHRoZSBoYXNoIHZhbHVlIG9mIHRoZSBsZWF2ZXNcbiAgICAgKi9cbiAgICBoYXNoKGxlYXZlcykge1xuICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkobGVhdmVzLmxlbmd0aCA9PT0gdGhpcy5oYXNoTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzaEZ1bmMobGVhdmVzKTtcbiAgICB9XG59XG5leHBvcnRzLkFjY1F1ZXVlID0gQWNjUXVldWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BY2NRdWV1ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maci-crypto/build/ts/AccQueue.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maci-crypto/build/ts/babyjub.js":
/*!******************************************************!*\
  !*** ./node_modules/maci-crypto/build/ts/babyjub.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.genRandomBabyJubValue = exports.G2Point = exports.G1Point = void 0;\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/maci-crypto/build/ts/constants.js\");\n/**\n * @notice A class representing a point on the first group (G1)\n * of the Jubjub curve\n */\nclass G1Point {\n    /**\n     * Create a new instance of G1Point\n     * @param x the x coordinate\n     * @param y the y coordinate\n     */\n    constructor(x, y) {\n        (0, assert_1.default)(x < constants_1.SNARK_FIELD_SIZE && x >= 0, \"G1Point x out of range\");\n        (0, assert_1.default)(y < constants_1.SNARK_FIELD_SIZE && y >= 0, \"G1Point y out of range\");\n        this.x = x;\n        this.y = y;\n    }\n    /**\n     * Check whether two points are equal\n     * @param pt the point to compare with\n     * @returns whether they are equal or not\n     */\n    equals(pt) {\n        return this.x === pt.x && this.y === pt.y;\n    }\n    /**\n     * Return the point as a contract param in the form of an object\n     * @returns the point as a contract param\n     */\n    asContractParam() {\n        return {\n            x: this.x.toString(),\n            y: this.y.toString(),\n        };\n    }\n}\nexports.G1Point = G1Point;\n/**\n * @notice A class representing a point on the second group (G2)\n * of the Jubjub curve. This is usually an extension field of the\n * base field of the curve.\n */\nclass G2Point {\n    /**\n     * Create a new instance of G2Point\n     * @param x the x coordinate\n     * @param y the y coordinate\n     */\n    constructor(x, y) {\n        this.checkPointsRange(x, \"x\");\n        this.checkPointsRange(y, \"y\");\n        this.x = x;\n        this.y = y;\n    }\n    /**\n     * Check whether two points are equal\n     * @param pt the point to compare with\n     * @returns whether they are equal or not\n     */\n    equals(pt) {\n        return this.x[0] === pt.x[0] && this.x[1] === pt.x[1] && this.y[0] === pt.y[0] && this.y[1] === pt.y[1];\n    }\n    /**\n     * Return the point as a contract param in the form of an object\n     * @returns the point as a contract param\n     */\n    asContractParam() {\n        return {\n            x: this.x.map((n) => n.toString()),\n            y: this.y.map((n) => n.toString()),\n        };\n    }\n    /**\n     * Check whether the points are in range\n     * @param x the x coordinate\n     * @param type the type of the coordinate\n     */\n    checkPointsRange(x, type) {\n        (0, assert_1.default)(x.every((n) => n < constants_1.SNARK_FIELD_SIZE && n >= 0), `G2Point ${type} out of range`);\n    }\n}\nexports.G2Point = G2Point;\n/**\n * Returns a BabyJub-compatible random value. We create it by first generating\n * a random value (initially 256 bits large) modulo the snark field size as\n * described in EIP197. This results in a key size of roughly 253 bits and no\n * more than 254 bits. To prevent modulo bias, we then use this efficient\n * algorithm:\n * http://cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/src/lib/libc/crypt/arc4random_uniform.c\n * @returns A BabyJub-compatible random value.\n */\nconst genRandomBabyJubValue = () => {\n    // Prevent modulo bias\n    // const lim = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000')\n    // const min = (lim - SNARK_FIELD_SIZE) % SNARK_FIELD_SIZE\n    const min = BigInt(\"6350874878119819312338956282401532410528162663560392320966563075034087161851\");\n    let privKey = constants_1.SNARK_FIELD_SIZE;\n    do {\n        const rand = BigInt(`0x${(0, crypto_1.randomBytes)(32).toString(\"hex\")}`);\n        if (rand >= min) {\n            privKey = rand % constants_1.SNARK_FIELD_SIZE;\n        }\n    } while (privKey >= constants_1.SNARK_FIELD_SIZE);\n    return privKey;\n};\nexports.genRandomBabyJubValue = genRandomBabyJubValue;\n//# sourceMappingURL=babyjub.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFjaS1jcnlwdG8vYnVpbGQvdHMvYmFieWp1Yi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixHQUFHLGVBQWUsR0FBRyxlQUFlO0FBQ2pFLGlDQUFpQyxtQkFBTyxDQUFDLHNCQUFRO0FBQ2pELGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLG9CQUFvQixtQkFBTyxDQUFDLDJFQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyxNQUFNO0FBQzNHO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsOENBQThDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9tYWNpLWNyeXB0by9idWlsZC90cy9iYWJ5anViLmpzPzQ4NTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdlblJhbmRvbUJhYnlKdWJWYWx1ZSA9IGV4cG9ydHMuRzJQb2ludCA9IGV4cG9ydHMuRzFQb2ludCA9IHZvaWQgMDtcbmNvbnN0IGFzc2VydF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG4vKipcbiAqIEBub3RpY2UgQSBjbGFzcyByZXByZXNlbnRpbmcgYSBwb2ludCBvbiB0aGUgZmlyc3QgZ3JvdXAgKEcxKVxuICogb2YgdGhlIEp1Ymp1YiBjdXJ2ZVxuICovXG5jbGFzcyBHMVBvaW50IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgRzFQb2ludFxuICAgICAqIEBwYXJhbSB4IHRoZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0geSB0aGUgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeCwgeSkge1xuICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoeCA8IGNvbnN0YW50c18xLlNOQVJLX0ZJRUxEX1NJWkUgJiYgeCA+PSAwLCBcIkcxUG9pbnQgeCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KSh5IDwgY29uc3RhbnRzXzEuU05BUktfRklFTERfU0laRSAmJiB5ID49IDAsIFwiRzFQb2ludCB5IG91dCBvZiByYW5nZVwiKTtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0d28gcG9pbnRzIGFyZSBlcXVhbFxuICAgICAqIEBwYXJhbSBwdCB0aGUgcG9pbnQgdG8gY29tcGFyZSB3aXRoXG4gICAgICogQHJldHVybnMgd2hldGhlciB0aGV5IGFyZSBlcXVhbCBvciBub3RcbiAgICAgKi9cbiAgICBlcXVhbHMocHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gcHQueCAmJiB0aGlzLnkgPT09IHB0Lnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcG9pbnQgYXMgYSBjb250cmFjdCBwYXJhbSBpbiB0aGUgZm9ybSBvZiBhbiBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB0aGUgcG9pbnQgYXMgYSBjb250cmFjdCBwYXJhbVxuICAgICAqL1xuICAgIGFzQ29udHJhY3RQYXJhbSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHRoaXMueC50b1N0cmluZygpLFxuICAgICAgICAgICAgeTogdGhpcy55LnRvU3RyaW5nKCksXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5HMVBvaW50ID0gRzFQb2ludDtcbi8qKlxuICogQG5vdGljZSBBIGNsYXNzIHJlcHJlc2VudGluZyBhIHBvaW50IG9uIHRoZSBzZWNvbmQgZ3JvdXAgKEcyKVxuICogb2YgdGhlIEp1Ymp1YiBjdXJ2ZS4gVGhpcyBpcyB1c3VhbGx5IGFuIGV4dGVuc2lvbiBmaWVsZCBvZiB0aGVcbiAqIGJhc2UgZmllbGQgb2YgdGhlIGN1cnZlLlxuICovXG5jbGFzcyBHMlBvaW50IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgRzJQb2ludFxuICAgICAqIEBwYXJhbSB4IHRoZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0geSB0aGUgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeCwgeSkge1xuICAgICAgICB0aGlzLmNoZWNrUG9pbnRzUmFuZ2UoeCwgXCJ4XCIpO1xuICAgICAgICB0aGlzLmNoZWNrUG9pbnRzUmFuZ2UoeSwgXCJ5XCIpO1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHR3byBwb2ludHMgYXJlIGVxdWFsXG4gICAgICogQHBhcmFtIHB0IHRoZSBwb2ludCB0byBjb21wYXJlIHdpdGhcbiAgICAgKiBAcmV0dXJucyB3aGV0aGVyIHRoZXkgYXJlIGVxdWFsIG9yIG5vdFxuICAgICAqL1xuICAgIGVxdWFscyhwdCkge1xuICAgICAgICByZXR1cm4gdGhpcy54WzBdID09PSBwdC54WzBdICYmIHRoaXMueFsxXSA9PT0gcHQueFsxXSAmJiB0aGlzLnlbMF0gPT09IHB0LnlbMF0gJiYgdGhpcy55WzFdID09PSBwdC55WzFdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHBvaW50IGFzIGEgY29udHJhY3QgcGFyYW0gaW4gdGhlIGZvcm0gb2YgYW4gb2JqZWN0XG4gICAgICogQHJldHVybnMgdGhlIHBvaW50IGFzIGEgY29udHJhY3QgcGFyYW1cbiAgICAgKi9cbiAgICBhc0NvbnRyYWN0UGFyYW0oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB0aGlzLngubWFwKChuKSA9PiBuLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgeTogdGhpcy55Lm1hcCgobikgPT4gbi50b1N0cmluZygpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgcG9pbnRzIGFyZSBpbiByYW5nZVxuICAgICAqIEBwYXJhbSB4IHRoZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSBvZiB0aGUgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGNoZWNrUG9pbnRzUmFuZ2UoeCwgdHlwZSkge1xuICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoeC5ldmVyeSgobikgPT4gbiA8IGNvbnN0YW50c18xLlNOQVJLX0ZJRUxEX1NJWkUgJiYgbiA+PSAwKSwgYEcyUG9pbnQgJHt0eXBlfSBvdXQgb2YgcmFuZ2VgKTtcbiAgICB9XG59XG5leHBvcnRzLkcyUG9pbnQgPSBHMlBvaW50O1xuLyoqXG4gKiBSZXR1cm5zIGEgQmFieUp1Yi1jb21wYXRpYmxlIHJhbmRvbSB2YWx1ZS4gV2UgY3JlYXRlIGl0IGJ5IGZpcnN0IGdlbmVyYXRpbmdcbiAqIGEgcmFuZG9tIHZhbHVlIChpbml0aWFsbHkgMjU2IGJpdHMgbGFyZ2UpIG1vZHVsbyB0aGUgc25hcmsgZmllbGQgc2l6ZSBhc1xuICogZGVzY3JpYmVkIGluIEVJUDE5Ny4gVGhpcyByZXN1bHRzIGluIGEga2V5IHNpemUgb2Ygcm91Z2hseSAyNTMgYml0cyBhbmQgbm9cbiAqIG1vcmUgdGhhbiAyNTQgYml0cy4gVG8gcHJldmVudCBtb2R1bG8gYmlhcywgd2UgdGhlbiB1c2UgdGhpcyBlZmZpY2llbnRcbiAqIGFsZ29yaXRobTpcbiAqIGh0dHA6Ly9jdnN3ZWIub3BlbmJzZC5vcmcvY2dpLWJpbi9jdnN3ZWIvfmNoZWNrb3V0fi9zcmMvbGliL2xpYmMvY3J5cHQvYXJjNHJhbmRvbV91bmlmb3JtLmNcbiAqIEByZXR1cm5zIEEgQmFieUp1Yi1jb21wYXRpYmxlIHJhbmRvbSB2YWx1ZS5cbiAqL1xuY29uc3QgZ2VuUmFuZG9tQmFieUp1YlZhbHVlID0gKCkgPT4ge1xuICAgIC8vIFByZXZlbnQgbW9kdWxvIGJpYXNcbiAgICAvLyBjb25zdCBsaW0gPSBCaWdJbnQoJzB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKVxuICAgIC8vIGNvbnN0IG1pbiA9IChsaW0gLSBTTkFSS19GSUVMRF9TSVpFKSAlIFNOQVJLX0ZJRUxEX1NJWkVcbiAgICBjb25zdCBtaW4gPSBCaWdJbnQoXCI2MzUwODc0ODc4MTE5ODE5MzEyMzM4OTU2MjgyNDAxNTMyNDEwNTI4MTYyNjYzNTYwMzkyMzIwOTY2NTYzMDc1MDM0MDg3MTYxODUxXCIpO1xuICAgIGxldCBwcml2S2V5ID0gY29uc3RhbnRzXzEuU05BUktfRklFTERfU0laRTtcbiAgICBkbyB7XG4gICAgICAgIGNvbnN0IHJhbmQgPSBCaWdJbnQoYDB4JHsoMCwgY3J5cHRvXzEucmFuZG9tQnl0ZXMpKDMyKS50b1N0cmluZyhcImhleFwiKX1gKTtcbiAgICAgICAgaWYgKHJhbmQgPj0gbWluKSB7XG4gICAgICAgICAgICBwcml2S2V5ID0gcmFuZCAlIGNvbnN0YW50c18xLlNOQVJLX0ZJRUxEX1NJWkU7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChwcml2S2V5ID49IGNvbnN0YW50c18xLlNOQVJLX0ZJRUxEX1NJWkUpO1xuICAgIHJldHVybiBwcml2S2V5O1xufTtcbmV4cG9ydHMuZ2VuUmFuZG9tQmFieUp1YlZhbHVlID0gZ2VuUmFuZG9tQmFieUp1YlZhbHVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFieWp1Yi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maci-crypto/build/ts/babyjub.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maci-crypto/build/ts/bigIntUtils.js":
/*!**********************************************************!*\
  !*** ./node_modules/maci-crypto/build/ts/bigIntUtils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bigInt2Buffer = exports.shiftRight = exports.deepCopyBigIntArray = exports.stringifyBigInts = exports.fromRprLE = exports.fromString = exports.unstringifyBigInts = void 0;\n/**\n * Given an input containing string values, convert them\n * to bigint\n * @param input - The input to convert\n * @returns the input with string values converted to bigint\n */\nconst unstringifyBigInts = (input) => {\n    if (typeof input === \"string\" && /^[0-9]+$/.test(input)) {\n        return BigInt(input);\n    }\n    if (typeof input === \"string\" && /^0x[0-9a-fA-F]+$/.test(input)) {\n        return BigInt(input);\n    }\n    if (Array.isArray(input)) {\n        return input.map(exports.unstringifyBigInts);\n    }\n    if (input === null) {\n        return null;\n    }\n    if (typeof input === \"object\") {\n        return Object.entries(input).reduce((acc, [key, value]) => {\n            acc[key] = (0, exports.unstringifyBigInts)(value);\n            return acc;\n        }, {});\n    }\n    return input;\n};\nexports.unstringifyBigInts = unstringifyBigInts;\n/**\n * Converts a string to a bigint using the given radix\n * @param str - The string to convert\n * @param radix - The radix to use\n * @returns The converted string as a bigint\n */\nconst fromString = (str, radix) => {\n    if (!radix || radix === 10) {\n        return BigInt(str);\n    }\n    if (radix === 16) {\n        if (str.startsWith(\"0x\")) {\n            return BigInt(str);\n        }\n        return BigInt(`0x${str}`);\n    }\n    return BigInt(str);\n};\nexports.fromString = fromString;\n/**\n * Parses a buffer with Little Endian Representation\n * @param buff - The buffer to parse\n * @param o - The offset to start from\n * @param n8 - The byte length\n * @returns The parsed buffer as a string\n */\nconst fromRprLE = (buff, o = 0, n8 = buff.byteLength) => {\n    const v = new Uint32Array(buff.buffer, buff.byteOffset + o, n8 / 4);\n    const a = new Array(n8 / 4);\n    v.forEach((ch, i) => {\n        a[a.length - i - 1] = ch.toString(16).padStart(8, \"0\");\n    });\n    return (0, exports.fromString)(a.join(\"\"), 16).toString();\n};\nexports.fromRprLE = fromRprLE;\n/**\n * Given an input of bigint values, convert them to their string representations\n * @param input - The input to convert\n * @returns The input with bigint values converted to string\n */\nconst stringifyBigInts = (input) => {\n    if (typeof input === \"bigint\") {\n        return input.toString();\n    }\n    if (input instanceof Uint8Array) {\n        return (0, exports.fromRprLE)(input, 0);\n    }\n    if (Array.isArray(input)) {\n        return input.map(exports.stringifyBigInts);\n    }\n    if (input === null) {\n        return null;\n    }\n    if (typeof input === \"object\") {\n        return Object.entries(input).reduce((acc, [key, value]) => {\n            acc[key] = (0, exports.stringifyBigInts)(value);\n            return acc;\n        }, {});\n    }\n    return input;\n};\nexports.stringifyBigInts = stringifyBigInts;\n/**\n * Create a copy of a bigint array\n * @param arr - the array of bigints to copy\n * @returns a deep copy of the array\n */\nconst deepCopyBigIntArray = (arr) => arr.map((x) => BigInt(x.toString()));\nexports.deepCopyBigIntArray = deepCopyBigIntArray;\n/**\n * Sihft a left by n bits\n * @param a - The first bigint\n * @param n - The second bigint\n * @returns The result of shifting a right by n\n */\nconst shiftRight = (a, n) => \n// eslint-disable-next-line no-bitwise\na >> n;\nexports.shiftRight = shiftRight;\n/**\n * Convert a BigInt to a Buffer\n * @param i - the bigint to convert\n * @returns the buffer\n */\nconst bigInt2Buffer = (i) => {\n    let hex = i.toString(16);\n    // Ensure even length.\n    if (hex.length % 2 !== 0) {\n        hex = `0${hex}`;\n    }\n    return Buffer.from(hex, \"hex\");\n};\nexports.bigInt2Buffer = bigInt2Buffer;\n//# sourceMappingURL=bigIntUtils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFjaS1jcnlwdG8vYnVpbGQvdHMvYmlnSW50VXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsa0JBQWtCLEdBQUcsMkJBQTJCLEdBQUcsd0JBQXdCLEdBQUcsaUJBQWlCLEdBQUcsa0JBQWtCLEdBQUcsMEJBQTBCO0FBQ3pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixJQUFJO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvbWFjaS1jcnlwdG8vYnVpbGQvdHMvYmlnSW50VXRpbHMuanM/YzIwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmlnSW50MkJ1ZmZlciA9IGV4cG9ydHMuc2hpZnRSaWdodCA9IGV4cG9ydHMuZGVlcENvcHlCaWdJbnRBcnJheSA9IGV4cG9ydHMuc3RyaW5naWZ5QmlnSW50cyA9IGV4cG9ydHMuZnJvbVJwckxFID0gZXhwb3J0cy5mcm9tU3RyaW5nID0gZXhwb3J0cy51bnN0cmluZ2lmeUJpZ0ludHMgPSB2b2lkIDA7XG4vKipcbiAqIEdpdmVuIGFuIGlucHV0IGNvbnRhaW5pbmcgc3RyaW5nIHZhbHVlcywgY29udmVydCB0aGVtXG4gKiB0byBiaWdpbnRcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSBpbnB1dCB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB0aGUgaW5wdXQgd2l0aCBzdHJpbmcgdmFsdWVzIGNvbnZlcnRlZCB0byBiaWdpbnRcbiAqL1xuY29uc3QgdW5zdHJpbmdpZnlCaWdJbnRzID0gKGlucHV0KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIiAmJiAvXlswLTldKyQvLnRlc3QoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQoaW5wdXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiICYmIC9eMHhbMC05YS1mQS1GXSskLy50ZXN0KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gQmlnSW50KGlucHV0KTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5tYXAoZXhwb3J0cy51bnN0cmluZ2lmeUJpZ0ludHMpO1xuICAgIH1cbiAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGlucHV0KS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9ICgwLCBleHBvcnRzLnVuc3RyaW5naWZ5QmlnSW50cykodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQ7XG59O1xuZXhwb3J0cy51bnN0cmluZ2lmeUJpZ0ludHMgPSB1bnN0cmluZ2lmeUJpZ0ludHM7XG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIHRvIGEgYmlnaW50IHVzaW5nIHRoZSBnaXZlbiByYWRpeFxuICogQHBhcmFtIHN0ciAtIFRoZSBzdHJpbmcgdG8gY29udmVydFxuICogQHBhcmFtIHJhZGl4IC0gVGhlIHJhZGl4IHRvIHVzZVxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBzdHJpbmcgYXMgYSBiaWdpbnRcbiAqL1xuY29uc3QgZnJvbVN0cmluZyA9IChzdHIsIHJhZGl4KSA9PiB7XG4gICAgaWYgKCFyYWRpeCB8fCByYWRpeCA9PT0gMTApIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludChzdHIpO1xuICAgIH1cbiAgICBpZiAocmFkaXggPT09IDE2KSB7XG4gICAgICAgIGlmIChzdHIuc3RhcnRzV2l0aChcIjB4XCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHN0cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZ0ludChgMHgke3N0cn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludChzdHIpO1xufTtcbmV4cG9ydHMuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XG4vKipcbiAqIFBhcnNlcyBhIGJ1ZmZlciB3aXRoIExpdHRsZSBFbmRpYW4gUmVwcmVzZW50YXRpb25cbiAqIEBwYXJhbSBidWZmIC0gVGhlIGJ1ZmZlciB0byBwYXJzZVxuICogQHBhcmFtIG8gLSBUaGUgb2Zmc2V0IHRvIHN0YXJ0IGZyb21cbiAqIEBwYXJhbSBuOCAtIFRoZSBieXRlIGxlbmd0aFxuICogQHJldHVybnMgVGhlIHBhcnNlZCBidWZmZXIgYXMgYSBzdHJpbmdcbiAqL1xuY29uc3QgZnJvbVJwckxFID0gKGJ1ZmYsIG8gPSAwLCBuOCA9IGJ1ZmYuYnl0ZUxlbmd0aCkgPT4ge1xuICAgIGNvbnN0IHYgPSBuZXcgVWludDMyQXJyYXkoYnVmZi5idWZmZXIsIGJ1ZmYuYnl0ZU9mZnNldCArIG8sIG44IC8gNCk7XG4gICAgY29uc3QgYSA9IG5ldyBBcnJheShuOCAvIDQpO1xuICAgIHYuZm9yRWFjaCgoY2gsIGkpID0+IHtcbiAgICAgICAgYVthLmxlbmd0aCAtIGkgLSAxXSA9IGNoLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LCBcIjBcIik7XG4gICAgfSk7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmZyb21TdHJpbmcpKGEuam9pbihcIlwiKSwgMTYpLnRvU3RyaW5nKCk7XG59O1xuZXhwb3J0cy5mcm9tUnByTEUgPSBmcm9tUnByTEU7XG4vKipcbiAqIEdpdmVuIGFuIGlucHV0IG9mIGJpZ2ludCB2YWx1ZXMsIGNvbnZlcnQgdGhlbSB0byB0aGVpciBzdHJpbmcgcmVwcmVzZW50YXRpb25zXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgaW5wdXQgdG8gY29udmVydFxuICogQHJldHVybnMgVGhlIGlucHV0IHdpdGggYmlnaW50IHZhbHVlcyBjb252ZXJ0ZWQgdG8gc3RyaW5nXG4gKi9cbmNvbnN0IHN0cmluZ2lmeUJpZ0ludHMgPSAoaW5wdXQpID0+IHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5mcm9tUnByTEUpKGlucHV0LCAwKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5tYXAoZXhwb3J0cy5zdHJpbmdpZnlCaWdJbnRzKTtcbiAgICB9XG4gICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhpbnB1dCkucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgYWNjW2tleV0gPSAoMCwgZXhwb3J0cy5zdHJpbmdpZnlCaWdJbnRzKSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dDtcbn07XG5leHBvcnRzLnN0cmluZ2lmeUJpZ0ludHMgPSBzdHJpbmdpZnlCaWdJbnRzO1xuLyoqXG4gKiBDcmVhdGUgYSBjb3B5IG9mIGEgYmlnaW50IGFycmF5XG4gKiBAcGFyYW0gYXJyIC0gdGhlIGFycmF5IG9mIGJpZ2ludHMgdG8gY29weVxuICogQHJldHVybnMgYSBkZWVwIGNvcHkgb2YgdGhlIGFycmF5XG4gKi9cbmNvbnN0IGRlZXBDb3B5QmlnSW50QXJyYXkgPSAoYXJyKSA9PiBhcnIubWFwKCh4KSA9PiBCaWdJbnQoeC50b1N0cmluZygpKSk7XG5leHBvcnRzLmRlZXBDb3B5QmlnSW50QXJyYXkgPSBkZWVwQ29weUJpZ0ludEFycmF5O1xuLyoqXG4gKiBTaWhmdCBhIGxlZnQgYnkgbiBiaXRzXG4gKiBAcGFyYW0gYSAtIFRoZSBmaXJzdCBiaWdpbnRcbiAqIEBwYXJhbSBuIC0gVGhlIHNlY29uZCBiaWdpbnRcbiAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2Ygc2hpZnRpbmcgYSByaWdodCBieSBuXG4gKi9cbmNvbnN0IHNoaWZ0UmlnaHQgPSAoYSwgbikgPT4gXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuYSA+PiBuO1xuZXhwb3J0cy5zaGlmdFJpZ2h0ID0gc2hpZnRSaWdodDtcbi8qKlxuICogQ29udmVydCBhIEJpZ0ludCB0byBhIEJ1ZmZlclxuICogQHBhcmFtIGkgLSB0aGUgYmlnaW50IHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHRoZSBidWZmZXJcbiAqL1xuY29uc3QgYmlnSW50MkJ1ZmZlciA9IChpKSA9PiB7XG4gICAgbGV0IGhleCA9IGkudG9TdHJpbmcoMTYpO1xuICAgIC8vIEVuc3VyZSBldmVuIGxlbmd0aC5cbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgaGV4ID0gYDAke2hleH1gO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oaGV4LCBcImhleFwiKTtcbn07XG5leHBvcnRzLmJpZ0ludDJCdWZmZXIgPSBiaWdJbnQyQnVmZmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmlnSW50VXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maci-crypto/build/ts/bigIntUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maci-crypto/build/ts/constants.js":
/*!********************************************************!*\
  !*** ./node_modules/maci-crypto/build/ts/constants.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NOTHING_UP_MY_SLEEVE = exports.SNARK_FIELD_SIZE = void 0;\nconst baby_jubjub_1 = __webpack_require__(/*! @zk-kit/baby-jubjub */ \"(ssr)/./node_modules/@zk-kit/baby-jubjub/dist/index.cjs\");\nconst ethers_1 = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.commonjs/index.js\");\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nexports.SNARK_FIELD_SIZE = baby_jubjub_1.r;\n// A nothing-up-my-sleeve zero value\n// Should be equal to 8370432830353022751713833565135785980866757267633941821328460903436894336785\nexports.NOTHING_UP_MY_SLEEVE = BigInt((0, ethers_1.keccak256)((0, ethers_1.toUtf8Bytes)(\"Maci\"))) % exports.SNARK_FIELD_SIZE;\n(0, assert_1.default)(exports.NOTHING_UP_MY_SLEEVE === BigInt(\"8370432830353022751713833565135785980866757267633941821328460903436894336785\"));\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFjaS1jcnlwdG8vYnVpbGQvdHMvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsd0JBQXdCO0FBQ3ZELHNCQUFzQixtQkFBTyxDQUFDLG9GQUFxQjtBQUNuRCxpQkFBaUIsbUJBQU8sQ0FBQyxpRUFBUTtBQUNqQyxpQ0FBaUMsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqRCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9tYWNpLWNyeXB0by9idWlsZC90cy9jb25zdGFudHMuanM/ZDM0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTk9USElOR19VUF9NWV9TTEVFVkUgPSBleHBvcnRzLlNOQVJLX0ZJRUxEX1NJWkUgPSB2b2lkIDA7XG5jb25zdCBiYWJ5X2p1Ymp1Yl8xID0gcmVxdWlyZShcIkB6ay1raXQvYmFieS1qdWJqdWJcIik7XG5jb25zdCBldGhlcnNfMSA9IHJlcXVpcmUoXCJldGhlcnNcIik7XG5jb25zdCBhc3NlcnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXNzZXJ0XCIpKTtcbmV4cG9ydHMuU05BUktfRklFTERfU0laRSA9IGJhYnlfanVianViXzEucjtcbi8vIEEgbm90aGluZy11cC1teS1zbGVldmUgemVybyB2YWx1ZVxuLy8gU2hvdWxkIGJlIGVxdWFsIHRvIDgzNzA0MzI4MzAzNTMwMjI3NTE3MTM4MzM1NjUxMzU3ODU5ODA4NjY3NTcyNjc2MzM5NDE4MjEzMjg0NjA5MDM0MzY4OTQzMzY3ODVcbmV4cG9ydHMuTk9USElOR19VUF9NWV9TTEVFVkUgPSBCaWdJbnQoKDAsIGV0aGVyc18xLmtlY2NhazI1NikoKDAsIGV0aGVyc18xLnRvVXRmOEJ5dGVzKShcIk1hY2lcIikpKSAlIGV4cG9ydHMuU05BUktfRklFTERfU0laRTtcbigwLCBhc3NlcnRfMS5kZWZhdWx0KShleHBvcnRzLk5PVEhJTkdfVVBfTVlfU0xFRVZFID09PSBCaWdJbnQoXCI4MzcwNDMyODMwMzUzMDIyNzUxNzEzODMzNTY1MTM1Nzg1OTgwODY2NzU3MjY3NjMzOTQxODIxMzI4NDYwOTAzNDM2ODk0MzM2Nzg1XCIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maci-crypto/build/ts/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maci-crypto/build/ts/hashing.js":
/*!******************************************************!*\
  !*** ./node_modules/maci-crypto/build/ts/hashing.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hashOne = exports.hash12 = exports.hash5 = exports.hash4 = exports.hash3 = exports.hash2 = exports.hashN = exports.hashLeftRight = exports.poseidonT6 = exports.poseidonT5 = exports.poseidonT4 = exports.poseidonT3 = exports.poseidon = exports.sha256Hash = void 0;\nconst poseidon_cipher_1 = __webpack_require__(/*! @zk-kit/poseidon-cipher */ \"(ssr)/./node_modules/@zk-kit/poseidon-cipher/dist/index.cjs\");\nconst ethers_1 = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.commonjs/index.js\");\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/maci-crypto/build/ts/constants.js\");\n/**\n * Hash an array of uint256 values the same way that the EVM does.\n * @param input - the array of values to hash\n * @returns a EVM compatible sha256 hash\n */\nconst sha256Hash = (input) => {\n    const types = [];\n    input.forEach(() => {\n        types.push(\"uint256\");\n    });\n    return (BigInt((0, ethers_1.solidityPackedSha256)(types, input.map((x) => x.toString()))) % constants_1.SNARK_FIELD_SIZE);\n};\nexports.sha256Hash = sha256Hash;\n/**\n * Generate the poseidon hash of the inputs provided\n * @param inputs The inputs to hash\n * @returns the hash of the inputs\n */\nconst poseidon = (inputs) => (0, poseidon_cipher_1.poseidonPerm)([BigInt(0), ...inputs.map((x) => BigInt(x))])[0];\nexports.poseidon = poseidon;\n/**\n * Hash up to 2 elements\n * @param inputs The elements to hash\n * @returns the hash of the elements\n */\nconst poseidonT3 = (inputs) => {\n    (0, assert_1.default)(inputs.length === 2);\n    return (0, exports.poseidon)(inputs);\n};\nexports.poseidonT3 = poseidonT3;\n/**\n * Hash up to 3 elements\n * @param inputs The elements to hash\n * @returns the hash of the elements\n */\nconst poseidonT4 = (inputs) => {\n    (0, assert_1.default)(inputs.length === 3);\n    return (0, exports.poseidon)(inputs);\n};\nexports.poseidonT4 = poseidonT4;\n/**\n * Hash up to 4 elements\n * @param inputs The elements to hash\n * @returns the hash of the elements\n */\nconst poseidonT5 = (inputs) => {\n    (0, assert_1.default)(inputs.length === 4);\n    return (0, exports.poseidon)(inputs);\n};\nexports.poseidonT5 = poseidonT5;\n/**\n * Hash up to 5 elements\n * @param inputs The elements to hash\n * @returns the hash of the elements\n */\nconst poseidonT6 = (inputs) => {\n    (0, assert_1.default)(inputs.length === 5);\n    return (0, exports.poseidon)(inputs);\n};\nexports.poseidonT6 = poseidonT6;\n/**\n * Hash two BigInts with the Poseidon hash function\n * @param left The left-hand element to hash\n * @param right The right-hand element to hash\n * @returns The hash of the two elements\n */\nconst hashLeftRight = (left, right) => (0, exports.poseidonT3)([left, right]);\nexports.hashLeftRight = hashLeftRight;\n// hash functions\nconst funcs = {\n    2: exports.poseidonT3,\n    3: exports.poseidonT4,\n    4: exports.poseidonT5,\n    5: exports.poseidonT6,\n};\n/**\n * Hash up to N elements\n * @param numElements The number of elements to hash\n * @param elements The elements to hash\n * @returns The hash of the elements\n */\nconst hashN = (numElements, elements) => {\n    const elementLength = elements.length;\n    if (elements.length > numElements) {\n        throw new TypeError(`the length of the elements array should be at most ${numElements}; got ${elements.length}`);\n    }\n    const elementsPadded = elements.slice();\n    if (elementLength < numElements) {\n        for (let i = elementLength; i < numElements; i += 1) {\n            elementsPadded.push(BigInt(0));\n        }\n    }\n    return funcs[numElements](elementsPadded);\n};\nexports.hashN = hashN;\n// hash functions\nconst hash2 = (elements) => (0, exports.hashN)(2, elements);\nexports.hash2 = hash2;\nconst hash3 = (elements) => (0, exports.hashN)(3, elements);\nexports.hash3 = hash3;\nconst hash4 = (elements) => (0, exports.hashN)(4, elements);\nexports.hash4 = hash4;\nconst hash5 = (elements) => (0, exports.hashN)(5, elements);\nexports.hash5 = hash5;\n/**\n * A convenience function to use Poseidon to hash a Plaintext with\n * no more than 13 elements\n * @param elements The elements to hash\n * @returns The hash of the elements\n */\nconst hash12 = (elements) => {\n    const max = 12;\n    const elementLength = elements.length;\n    if (elementLength > max) {\n        throw new TypeError(`the length of the elements array should be at most ${max}; got ${elements.length}`);\n    }\n    const elementsPadded = elements.slice();\n    if (elementLength < max) {\n        for (let i = elementLength; i < max; i += 1) {\n            elementsPadded.push(BigInt(0));\n        }\n    }\n    return (0, exports.poseidonT5)([\n        (0, exports.poseidonT6)(elementsPadded.slice(0, 5)),\n        (0, exports.poseidonT6)(elementsPadded.slice(5, 10)),\n        elementsPadded[10],\n        elementsPadded[11],\n    ]);\n};\nexports.hash12 = hash12;\n/**\n * Hash a single BigInt with the Poseidon hash function\n * @param preImage The element to hash\n * @returns The hash of the element\n */\nconst hashOne = (preImage) => (0, exports.poseidonT3)([preImage, BigInt(0)]);\nexports.hashOne = hashOne;\n//# sourceMappingURL=hashing.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFjaS1jcnlwdG8vYnVpbGQvdHMvaGFzaGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyxjQUFjLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxxQkFBcUIsR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0IsR0FBRyxnQkFBZ0IsR0FBRyxrQkFBa0I7QUFDcFEsMEJBQTBCLG1CQUFPLENBQUMsNEZBQXlCO0FBQzNELGlCQUFpQixtQkFBTyxDQUFDLGlFQUFRO0FBQ2pDLGlDQUFpQyxtQkFBTyxDQUFDLHNCQUFRO0FBQ2pELG9CQUFvQixtQkFBTyxDQUFDLDJFQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsY0FBYyxNQUFNLGdCQUFnQjtBQUN0SDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixNQUFNLE1BQU0sZ0JBQWdCO0FBQzlHO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvbWFjaS1jcnlwdG8vYnVpbGQvdHMvaGFzaGluZy5qcz82N2JkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYXNoT25lID0gZXhwb3J0cy5oYXNoMTIgPSBleHBvcnRzLmhhc2g1ID0gZXhwb3J0cy5oYXNoNCA9IGV4cG9ydHMuaGFzaDMgPSBleHBvcnRzLmhhc2gyID0gZXhwb3J0cy5oYXNoTiA9IGV4cG9ydHMuaGFzaExlZnRSaWdodCA9IGV4cG9ydHMucG9zZWlkb25UNiA9IGV4cG9ydHMucG9zZWlkb25UNSA9IGV4cG9ydHMucG9zZWlkb25UNCA9IGV4cG9ydHMucG9zZWlkb25UMyA9IGV4cG9ydHMucG9zZWlkb24gPSBleHBvcnRzLnNoYTI1Nkhhc2ggPSB2b2lkIDA7XG5jb25zdCBwb3NlaWRvbl9jaXBoZXJfMSA9IHJlcXVpcmUoXCJAemsta2l0L3Bvc2VpZG9uLWNpcGhlclwiKTtcbmNvbnN0IGV0aGVyc18xID0gcmVxdWlyZShcImV0aGVyc1wiKTtcbmNvbnN0IGFzc2VydF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG4vKipcbiAqIEhhc2ggYW4gYXJyYXkgb2YgdWludDI1NiB2YWx1ZXMgdGhlIHNhbWUgd2F5IHRoYXQgdGhlIEVWTSBkb2VzLlxuICogQHBhcmFtIGlucHV0IC0gdGhlIGFycmF5IG9mIHZhbHVlcyB0byBoYXNoXG4gKiBAcmV0dXJucyBhIEVWTSBjb21wYXRpYmxlIHNoYTI1NiBoYXNoXG4gKi9cbmNvbnN0IHNoYTI1Nkhhc2ggPSAoaW5wdXQpID0+IHtcbiAgICBjb25zdCB0eXBlcyA9IFtdO1xuICAgIGlucHV0LmZvckVhY2goKCkgPT4ge1xuICAgICAgICB0eXBlcy5wdXNoKFwidWludDI1NlwiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKEJpZ0ludCgoMCwgZXRoZXJzXzEuc29saWRpdHlQYWNrZWRTaGEyNTYpKHR5cGVzLCBpbnB1dC5tYXAoKHgpID0+IHgudG9TdHJpbmcoKSkpKSAlIGNvbnN0YW50c18xLlNOQVJLX0ZJRUxEX1NJWkUpO1xufTtcbmV4cG9ydHMuc2hhMjU2SGFzaCA9IHNoYTI1Nkhhc2g7XG4vKipcbiAqIEdlbmVyYXRlIHRoZSBwb3NlaWRvbiBoYXNoIG9mIHRoZSBpbnB1dHMgcHJvdmlkZWRcbiAqIEBwYXJhbSBpbnB1dHMgVGhlIGlucHV0cyB0byBoYXNoXG4gKiBAcmV0dXJucyB0aGUgaGFzaCBvZiB0aGUgaW5wdXRzXG4gKi9cbmNvbnN0IHBvc2VpZG9uID0gKGlucHV0cykgPT4gKDAsIHBvc2VpZG9uX2NpcGhlcl8xLnBvc2VpZG9uUGVybSkoW0JpZ0ludCgwKSwgLi4uaW5wdXRzLm1hcCgoeCkgPT4gQmlnSW50KHgpKV0pWzBdO1xuZXhwb3J0cy5wb3NlaWRvbiA9IHBvc2VpZG9uO1xuLyoqXG4gKiBIYXNoIHVwIHRvIDIgZWxlbWVudHNcbiAqIEBwYXJhbSBpbnB1dHMgVGhlIGVsZW1lbnRzIHRvIGhhc2hcbiAqIEByZXR1cm5zIHRoZSBoYXNoIG9mIHRoZSBlbGVtZW50c1xuICovXG5jb25zdCBwb3NlaWRvblQzID0gKGlucHV0cykgPT4ge1xuICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShpbnB1dHMubGVuZ3RoID09PSAyKTtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMucG9zZWlkb24pKGlucHV0cyk7XG59O1xuZXhwb3J0cy5wb3NlaWRvblQzID0gcG9zZWlkb25UMztcbi8qKlxuICogSGFzaCB1cCB0byAzIGVsZW1lbnRzXG4gKiBAcGFyYW0gaW5wdXRzIFRoZSBlbGVtZW50cyB0byBoYXNoXG4gKiBAcmV0dXJucyB0aGUgaGFzaCBvZiB0aGUgZWxlbWVudHNcbiAqL1xuY29uc3QgcG9zZWlkb25UNCA9IChpbnB1dHMpID0+IHtcbiAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoaW5wdXRzLmxlbmd0aCA9PT0gMyk7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLnBvc2VpZG9uKShpbnB1dHMpO1xufTtcbmV4cG9ydHMucG9zZWlkb25UNCA9IHBvc2VpZG9uVDQ7XG4vKipcbiAqIEhhc2ggdXAgdG8gNCBlbGVtZW50c1xuICogQHBhcmFtIGlucHV0cyBUaGUgZWxlbWVudHMgdG8gaGFzaFxuICogQHJldHVybnMgdGhlIGhhc2ggb2YgdGhlIGVsZW1lbnRzXG4gKi9cbmNvbnN0IHBvc2VpZG9uVDUgPSAoaW5wdXRzKSA9PiB7XG4gICAgKDAsIGFzc2VydF8xLmRlZmF1bHQpKGlucHV0cy5sZW5ndGggPT09IDQpO1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5wb3NlaWRvbikoaW5wdXRzKTtcbn07XG5leHBvcnRzLnBvc2VpZG9uVDUgPSBwb3NlaWRvblQ1O1xuLyoqXG4gKiBIYXNoIHVwIHRvIDUgZWxlbWVudHNcbiAqIEBwYXJhbSBpbnB1dHMgVGhlIGVsZW1lbnRzIHRvIGhhc2hcbiAqIEByZXR1cm5zIHRoZSBoYXNoIG9mIHRoZSBlbGVtZW50c1xuICovXG5jb25zdCBwb3NlaWRvblQ2ID0gKGlucHV0cykgPT4ge1xuICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShpbnB1dHMubGVuZ3RoID09PSA1KTtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMucG9zZWlkb24pKGlucHV0cyk7XG59O1xuZXhwb3J0cy5wb3NlaWRvblQ2ID0gcG9zZWlkb25UNjtcbi8qKlxuICogSGFzaCB0d28gQmlnSW50cyB3aXRoIHRoZSBQb3NlaWRvbiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbGVmdCBUaGUgbGVmdC1oYW5kIGVsZW1lbnQgdG8gaGFzaFxuICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodC1oYW5kIGVsZW1lbnQgdG8gaGFzaFxuICogQHJldHVybnMgVGhlIGhhc2ggb2YgdGhlIHR3byBlbGVtZW50c1xuICovXG5jb25zdCBoYXNoTGVmdFJpZ2h0ID0gKGxlZnQsIHJpZ2h0KSA9PiAoMCwgZXhwb3J0cy5wb3NlaWRvblQzKShbbGVmdCwgcmlnaHRdKTtcbmV4cG9ydHMuaGFzaExlZnRSaWdodCA9IGhhc2hMZWZ0UmlnaHQ7XG4vLyBoYXNoIGZ1bmN0aW9uc1xuY29uc3QgZnVuY3MgPSB7XG4gICAgMjogZXhwb3J0cy5wb3NlaWRvblQzLFxuICAgIDM6IGV4cG9ydHMucG9zZWlkb25UNCxcbiAgICA0OiBleHBvcnRzLnBvc2VpZG9uVDUsXG4gICAgNTogZXhwb3J0cy5wb3NlaWRvblQ2LFxufTtcbi8qKlxuICogSGFzaCB1cCB0byBOIGVsZW1lbnRzXG4gKiBAcGFyYW0gbnVtRWxlbWVudHMgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBoYXNoXG4gKiBAcGFyYW0gZWxlbWVudHMgVGhlIGVsZW1lbnRzIHRvIGhhc2hcbiAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoZSBlbGVtZW50c1xuICovXG5jb25zdCBoYXNoTiA9IChudW1FbGVtZW50cywgZWxlbWVudHMpID0+IHtcbiAgICBjb25zdCBlbGVtZW50TGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiBudW1FbGVtZW50cykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0aGUgbGVuZ3RoIG9mIHRoZSBlbGVtZW50cyBhcnJheSBzaG91bGQgYmUgYXQgbW9zdCAke251bUVsZW1lbnRzfTsgZ290ICR7ZWxlbWVudHMubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50c1BhZGRlZCA9IGVsZW1lbnRzLnNsaWNlKCk7XG4gICAgaWYgKGVsZW1lbnRMZW5ndGggPCBudW1FbGVtZW50cykge1xuICAgICAgICBmb3IgKGxldCBpID0gZWxlbWVudExlbmd0aDsgaSA8IG51bUVsZW1lbnRzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzUGFkZGVkLnB1c2goQmlnSW50KDApKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3NbbnVtRWxlbWVudHNdKGVsZW1lbnRzUGFkZGVkKTtcbn07XG5leHBvcnRzLmhhc2hOID0gaGFzaE47XG4vLyBoYXNoIGZ1bmN0aW9uc1xuY29uc3QgaGFzaDIgPSAoZWxlbWVudHMpID0+ICgwLCBleHBvcnRzLmhhc2hOKSgyLCBlbGVtZW50cyk7XG5leHBvcnRzLmhhc2gyID0gaGFzaDI7XG5jb25zdCBoYXNoMyA9IChlbGVtZW50cykgPT4gKDAsIGV4cG9ydHMuaGFzaE4pKDMsIGVsZW1lbnRzKTtcbmV4cG9ydHMuaGFzaDMgPSBoYXNoMztcbmNvbnN0IGhhc2g0ID0gKGVsZW1lbnRzKSA9PiAoMCwgZXhwb3J0cy5oYXNoTikoNCwgZWxlbWVudHMpO1xuZXhwb3J0cy5oYXNoNCA9IGhhc2g0O1xuY29uc3QgaGFzaDUgPSAoZWxlbWVudHMpID0+ICgwLCBleHBvcnRzLmhhc2hOKSg1LCBlbGVtZW50cyk7XG5leHBvcnRzLmhhc2g1ID0gaGFzaDU7XG4vKipcbiAqIEEgY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gdXNlIFBvc2VpZG9uIHRvIGhhc2ggYSBQbGFpbnRleHQgd2l0aFxuICogbm8gbW9yZSB0aGFuIDEzIGVsZW1lbnRzXG4gKiBAcGFyYW0gZWxlbWVudHMgVGhlIGVsZW1lbnRzIHRvIGhhc2hcbiAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoZSBlbGVtZW50c1xuICovXG5jb25zdCBoYXNoMTIgPSAoZWxlbWVudHMpID0+IHtcbiAgICBjb25zdCBtYXggPSAxMjtcbiAgICBjb25zdCBlbGVtZW50TGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuICAgIGlmIChlbGVtZW50TGVuZ3RoID4gbWF4KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHRoZSBsZW5ndGggb2YgdGhlIGVsZW1lbnRzIGFycmF5IHNob3VsZCBiZSBhdCBtb3N0ICR7bWF4fTsgZ290ICR7ZWxlbWVudHMubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50c1BhZGRlZCA9IGVsZW1lbnRzLnNsaWNlKCk7XG4gICAgaWYgKGVsZW1lbnRMZW5ndGggPCBtYXgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGVsZW1lbnRMZW5ndGg7IGkgPCBtYXg7IGkgKz0gMSkge1xuICAgICAgICAgICAgZWxlbWVudHNQYWRkZWQucHVzaChCaWdJbnQoMCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoMCwgZXhwb3J0cy5wb3NlaWRvblQ1KShbXG4gICAgICAgICgwLCBleHBvcnRzLnBvc2VpZG9uVDYpKGVsZW1lbnRzUGFkZGVkLnNsaWNlKDAsIDUpKSxcbiAgICAgICAgKDAsIGV4cG9ydHMucG9zZWlkb25UNikoZWxlbWVudHNQYWRkZWQuc2xpY2UoNSwgMTApKSxcbiAgICAgICAgZWxlbWVudHNQYWRkZWRbMTBdLFxuICAgICAgICBlbGVtZW50c1BhZGRlZFsxMV0sXG4gICAgXSk7XG59O1xuZXhwb3J0cy5oYXNoMTIgPSBoYXNoMTI7XG4vKipcbiAqIEhhc2ggYSBzaW5nbGUgQmlnSW50IHdpdGggdGhlIFBvc2VpZG9uIGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBwcmVJbWFnZSBUaGUgZWxlbWVudCB0byBoYXNoXG4gKiBAcmV0dXJucyBUaGUgaGFzaCBvZiB0aGUgZWxlbWVudFxuICovXG5jb25zdCBoYXNoT25lID0gKHByZUltYWdlKSA9PiAoMCwgZXhwb3J0cy5wb3NlaWRvblQzKShbcHJlSW1hZ2UsIEJpZ0ludCgwKV0pO1xuZXhwb3J0cy5oYXNoT25lID0gaGFzaE9uZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2hpbmcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maci-crypto/build/ts/hashing.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maci-crypto/build/ts/index.js":
/*!****************************************************!*\
  !*** ./node_modules/maci-crypto/build/ts/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sign = exports.verifySignature = exports.poseidonEncrypt = exports.poseidonDecryptWithoutCheck = exports.poseidonDecrypt = exports.inCurve = exports.hashOne = exports.hash12 = exports.hash5 = exports.hash4 = exports.hash3 = exports.hash2 = exports.hashN = exports.hashLeftRight = exports.sha256Hash = exports.genRandomBabyJubValue = exports.G2Point = exports.G1Point = exports.unpackPubKey = exports.packPubKey = exports.genEcdhSharedKey = exports.genKeypair = exports.genPubKey = exports.formatPrivKeyForBabyJub = exports.genRandomSalt = exports.genPrivKey = exports.SNARK_FIELD_SIZE = exports.NOTHING_UP_MY_SLEEVE = exports.deepCopyBigIntArray = exports.unstringifyBigInts = exports.stringifyBigInts = exports.bigInt2Buffer = exports.IncrementalQuinTree = exports.genTreeProof = exports.genTreeCommitment = exports.calcDepthFromNumLeaves = exports.AccQueue = void 0;\nvar AccQueue_1 = __webpack_require__(/*! ./AccQueue */ \"(ssr)/./node_modules/maci-crypto/build/ts/AccQueue.js\");\nObject.defineProperty(exports, \"AccQueue\", ({ enumerable: true, get: function () { return AccQueue_1.AccQueue; } }));\nvar utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/maci-crypto/build/ts/utils.js\");\nObject.defineProperty(exports, \"calcDepthFromNumLeaves\", ({ enumerable: true, get: function () { return utils_1.calcDepthFromNumLeaves; } }));\nObject.defineProperty(exports, \"genTreeCommitment\", ({ enumerable: true, get: function () { return utils_1.genTreeCommitment; } }));\nObject.defineProperty(exports, \"genTreeProof\", ({ enumerable: true, get: function () { return utils_1.genTreeProof; } }));\nvar quinTree_1 = __webpack_require__(/*! ./quinTree */ \"(ssr)/./node_modules/maci-crypto/build/ts/quinTree.js\");\nObject.defineProperty(exports, \"IncrementalQuinTree\", ({ enumerable: true, get: function () { return quinTree_1.IncrementalQuinTree; } }));\nvar bigIntUtils_1 = __webpack_require__(/*! ./bigIntUtils */ \"(ssr)/./node_modules/maci-crypto/build/ts/bigIntUtils.js\");\nObject.defineProperty(exports, \"bigInt2Buffer\", ({ enumerable: true, get: function () { return bigIntUtils_1.bigInt2Buffer; } }));\nObject.defineProperty(exports, \"stringifyBigInts\", ({ enumerable: true, get: function () { return bigIntUtils_1.stringifyBigInts; } }));\nObject.defineProperty(exports, \"unstringifyBigInts\", ({ enumerable: true, get: function () { return bigIntUtils_1.unstringifyBigInts; } }));\nObject.defineProperty(exports, \"deepCopyBigIntArray\", ({ enumerable: true, get: function () { return bigIntUtils_1.deepCopyBigIntArray; } }));\nvar constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/maci-crypto/build/ts/constants.js\");\nObject.defineProperty(exports, \"NOTHING_UP_MY_SLEEVE\", ({ enumerable: true, get: function () { return constants_1.NOTHING_UP_MY_SLEEVE; } }));\nObject.defineProperty(exports, \"SNARK_FIELD_SIZE\", ({ enumerable: true, get: function () { return constants_1.SNARK_FIELD_SIZE; } }));\nvar keys_1 = __webpack_require__(/*! ./keys */ \"(ssr)/./node_modules/maci-crypto/build/ts/keys.js\");\nObject.defineProperty(exports, \"genPrivKey\", ({ enumerable: true, get: function () { return keys_1.genPrivKey; } }));\nObject.defineProperty(exports, \"genRandomSalt\", ({ enumerable: true, get: function () { return keys_1.genRandomSalt; } }));\nObject.defineProperty(exports, \"formatPrivKeyForBabyJub\", ({ enumerable: true, get: function () { return keys_1.formatPrivKeyForBabyJub; } }));\nObject.defineProperty(exports, \"genPubKey\", ({ enumerable: true, get: function () { return keys_1.genPubKey; } }));\nObject.defineProperty(exports, \"genKeypair\", ({ enumerable: true, get: function () { return keys_1.genKeypair; } }));\nObject.defineProperty(exports, \"genEcdhSharedKey\", ({ enumerable: true, get: function () { return keys_1.genEcdhSharedKey; } }));\nObject.defineProperty(exports, \"packPubKey\", ({ enumerable: true, get: function () { return keys_1.packPubKey; } }));\nObject.defineProperty(exports, \"unpackPubKey\", ({ enumerable: true, get: function () { return keys_1.unpackPubKey; } }));\nvar babyjub_1 = __webpack_require__(/*! ./babyjub */ \"(ssr)/./node_modules/maci-crypto/build/ts/babyjub.js\");\nObject.defineProperty(exports, \"G1Point\", ({ enumerable: true, get: function () { return babyjub_1.G1Point; } }));\nObject.defineProperty(exports, \"G2Point\", ({ enumerable: true, get: function () { return babyjub_1.G2Point; } }));\nObject.defineProperty(exports, \"genRandomBabyJubValue\", ({ enumerable: true, get: function () { return babyjub_1.genRandomBabyJubValue; } }));\nvar hashing_1 = __webpack_require__(/*! ./hashing */ \"(ssr)/./node_modules/maci-crypto/build/ts/hashing.js\");\nObject.defineProperty(exports, \"sha256Hash\", ({ enumerable: true, get: function () { return hashing_1.sha256Hash; } }));\nObject.defineProperty(exports, \"hashLeftRight\", ({ enumerable: true, get: function () { return hashing_1.hashLeftRight; } }));\nObject.defineProperty(exports, \"hashN\", ({ enumerable: true, get: function () { return hashing_1.hashN; } }));\nObject.defineProperty(exports, \"hash2\", ({ enumerable: true, get: function () { return hashing_1.hash2; } }));\nObject.defineProperty(exports, \"hash3\", ({ enumerable: true, get: function () { return hashing_1.hash3; } }));\nObject.defineProperty(exports, \"hash4\", ({ enumerable: true, get: function () { return hashing_1.hash4; } }));\nObject.defineProperty(exports, \"hash5\", ({ enumerable: true, get: function () { return hashing_1.hash5; } }));\nObject.defineProperty(exports, \"hash12\", ({ enumerable: true, get: function () { return hashing_1.hash12; } }));\nObject.defineProperty(exports, \"hashOne\", ({ enumerable: true, get: function () { return hashing_1.hashOne; } }));\nvar baby_jubjub_1 = __webpack_require__(/*! @zk-kit/baby-jubjub */ \"(ssr)/./node_modules/@zk-kit/baby-jubjub/dist/index.cjs\");\nObject.defineProperty(exports, \"inCurve\", ({ enumerable: true, get: function () { return baby_jubjub_1.inCurve; } }));\nvar poseidon_cipher_1 = __webpack_require__(/*! @zk-kit/poseidon-cipher */ \"(ssr)/./node_modules/@zk-kit/poseidon-cipher/dist/index.cjs\");\nObject.defineProperty(exports, \"poseidonDecrypt\", ({ enumerable: true, get: function () { return poseidon_cipher_1.poseidonDecrypt; } }));\nObject.defineProperty(exports, \"poseidonDecryptWithoutCheck\", ({ enumerable: true, get: function () { return poseidon_cipher_1.poseidonDecryptWithoutCheck; } }));\nObject.defineProperty(exports, \"poseidonEncrypt\", ({ enumerable: true, get: function () { return poseidon_cipher_1.poseidonEncrypt; } }));\nvar eddsa_poseidon_1 = __webpack_require__(/*! @zk-kit/eddsa-poseidon */ \"(ssr)/./node_modules/@zk-kit/eddsa-poseidon/dist/index.cjs\");\nObject.defineProperty(exports, \"verifySignature\", ({ enumerable: true, get: function () { return eddsa_poseidon_1.verifySignature; } }));\nObject.defineProperty(exports, \"sign\", ({ enumerable: true, get: function () { return eddsa_poseidon_1.signMessage; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFjaS1jcnlwdG8vYnVpbGQvdHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWSxHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLG1DQUFtQyxHQUFHLHVCQUF1QixHQUFHLGVBQWUsR0FBRyxlQUFlLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcscUJBQXFCLEdBQUcsa0JBQWtCLEdBQUcsNkJBQTZCLEdBQUcsZUFBZSxHQUFHLGVBQWUsR0FBRyxvQkFBb0IsR0FBRyxrQkFBa0IsR0FBRyx3QkFBd0IsR0FBRyxrQkFBa0IsR0FBRyxpQkFBaUIsR0FBRywrQkFBK0IsR0FBRyxxQkFBcUIsR0FBRyxrQkFBa0IsR0FBRyx3QkFBd0IsR0FBRyw0QkFBNEIsR0FBRywyQkFBMkIsR0FBRywwQkFBMEIsR0FBRyx3QkFBd0IsR0FBRyxxQkFBcUIsR0FBRywyQkFBMkIsR0FBRyxvQkFBb0IsR0FBRyx5QkFBeUIsR0FBRyw4QkFBOEIsR0FBRyxnQkFBZ0I7QUFDbDJCLGlCQUFpQixtQkFBTyxDQUFDLHlFQUFZO0FBQ3JDLDRDQUEyQyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNsSCxjQUFjLG1CQUFPLENBQUMsbUVBQVM7QUFDL0IsMERBQXlELEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQzNJLHFEQUFvRCxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUNqSSxnREFBK0MsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDdkgsaUJBQWlCLG1CQUFPLENBQUMseUVBQVk7QUFDckMsdURBQXNELEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQ3hJLG9CQUFvQixtQkFBTyxDQUFDLCtFQUFlO0FBQzNDLGlEQUFnRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUMvSCxvREFBbUQsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDckksc0RBQXFELEVBQUUscUNBQXFDLDRDQUE0QyxFQUFDO0FBQ3pJLHVEQUFzRCxFQUFFLHFDQUFxQyw2Q0FBNkMsRUFBQztBQUMzSSxrQkFBa0IsbUJBQU8sQ0FBQywyRUFBYTtBQUN2Qyx3REFBdUQsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDM0ksb0RBQW1ELEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQ25JLGFBQWEsbUJBQU8sQ0FBQyxpRUFBUTtBQUM3Qiw4Q0FBNkMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDbEgsaURBQWdELEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3hILDJEQUEwRCxFQUFFLHFDQUFxQywwQ0FBMEMsRUFBQztBQUM1SSw2Q0FBNEMsRUFBRSxxQ0FBcUMsNEJBQTRCLEVBQUM7QUFDaEgsOENBQTZDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQ2xILG9EQUFtRCxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUM5SCw4Q0FBNkMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDbEgsZ0RBQStDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ3RILGdCQUFnQixtQkFBTyxDQUFDLHVFQUFXO0FBQ25DLDJDQUEwQyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUMvRywyQ0FBMEMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDL0cseURBQXdELEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQzNJLGdCQUFnQixtQkFBTyxDQUFDLHVFQUFXO0FBQ25DLDhDQUE2QyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUNySCxpREFBZ0QsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDM0gseUNBQXdDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQzNHLHlDQUF3QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUMzRyx5Q0FBd0MsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDM0cseUNBQXdDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQzNHLHlDQUF3QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUMzRywwQ0FBeUMsRUFBRSxxQ0FBcUMsNEJBQTRCLEVBQUM7QUFDN0csMkNBQTBDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQy9HLG9CQUFvQixtQkFBTyxDQUFDLG9GQUFxQjtBQUNqRCwyQ0FBMEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDbkgsd0JBQXdCLG1CQUFPLENBQUMsNEZBQXlCO0FBQ3pELG1EQUFrRCxFQUFFLHFDQUFxQyw2Q0FBNkMsRUFBQztBQUN2SSwrREFBOEQsRUFBRSxxQ0FBcUMseURBQXlELEVBQUM7QUFDL0osbURBQWtELEVBQUUscUNBQXFDLDZDQUE2QyxFQUFDO0FBQ3ZJLHVCQUF1QixtQkFBTyxDQUFDLDBGQUF3QjtBQUN2RCxtREFBa0QsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDdEksd0NBQXVDLEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQ3ZIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9tYWNpLWNyeXB0by9idWlsZC90cy9pbmRleC5qcz9jNjUwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaWduID0gZXhwb3J0cy52ZXJpZnlTaWduYXR1cmUgPSBleHBvcnRzLnBvc2VpZG9uRW5jcnlwdCA9IGV4cG9ydHMucG9zZWlkb25EZWNyeXB0V2l0aG91dENoZWNrID0gZXhwb3J0cy5wb3NlaWRvbkRlY3J5cHQgPSBleHBvcnRzLmluQ3VydmUgPSBleHBvcnRzLmhhc2hPbmUgPSBleHBvcnRzLmhhc2gxMiA9IGV4cG9ydHMuaGFzaDUgPSBleHBvcnRzLmhhc2g0ID0gZXhwb3J0cy5oYXNoMyA9IGV4cG9ydHMuaGFzaDIgPSBleHBvcnRzLmhhc2hOID0gZXhwb3J0cy5oYXNoTGVmdFJpZ2h0ID0gZXhwb3J0cy5zaGEyNTZIYXNoID0gZXhwb3J0cy5nZW5SYW5kb21CYWJ5SnViVmFsdWUgPSBleHBvcnRzLkcyUG9pbnQgPSBleHBvcnRzLkcxUG9pbnQgPSBleHBvcnRzLnVucGFja1B1YktleSA9IGV4cG9ydHMucGFja1B1YktleSA9IGV4cG9ydHMuZ2VuRWNkaFNoYXJlZEtleSA9IGV4cG9ydHMuZ2VuS2V5cGFpciA9IGV4cG9ydHMuZ2VuUHViS2V5ID0gZXhwb3J0cy5mb3JtYXRQcml2S2V5Rm9yQmFieUp1YiA9IGV4cG9ydHMuZ2VuUmFuZG9tU2FsdCA9IGV4cG9ydHMuZ2VuUHJpdktleSA9IGV4cG9ydHMuU05BUktfRklFTERfU0laRSA9IGV4cG9ydHMuTk9USElOR19VUF9NWV9TTEVFVkUgPSBleHBvcnRzLmRlZXBDb3B5QmlnSW50QXJyYXkgPSBleHBvcnRzLnVuc3RyaW5naWZ5QmlnSW50cyA9IGV4cG9ydHMuc3RyaW5naWZ5QmlnSW50cyA9IGV4cG9ydHMuYmlnSW50MkJ1ZmZlciA9IGV4cG9ydHMuSW5jcmVtZW50YWxRdWluVHJlZSA9IGV4cG9ydHMuZ2VuVHJlZVByb29mID0gZXhwb3J0cy5nZW5UcmVlQ29tbWl0bWVudCA9IGV4cG9ydHMuY2FsY0RlcHRoRnJvbU51bUxlYXZlcyA9IGV4cG9ydHMuQWNjUXVldWUgPSB2b2lkIDA7XG52YXIgQWNjUXVldWVfMSA9IHJlcXVpcmUoXCIuL0FjY1F1ZXVlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWNjUXVldWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFjY1F1ZXVlXzEuQWNjUXVldWU7IH0gfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2FsY0RlcHRoRnJvbU51bUxlYXZlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5jYWxjRGVwdGhGcm9tTnVtTGVhdmVzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2VuVHJlZUNvbW1pdG1lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuZ2VuVHJlZUNvbW1pdG1lbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZW5UcmVlUHJvb2ZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuZ2VuVHJlZVByb29mOyB9IH0pO1xudmFyIHF1aW5UcmVlXzEgPSByZXF1aXJlKFwiLi9xdWluVHJlZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkluY3JlbWVudGFsUXVpblRyZWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHF1aW5UcmVlXzEuSW5jcmVtZW50YWxRdWluVHJlZTsgfSB9KTtcbnZhciBiaWdJbnRVdGlsc18xID0gcmVxdWlyZShcIi4vYmlnSW50VXRpbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJiaWdJbnQyQnVmZmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaWdJbnRVdGlsc18xLmJpZ0ludDJCdWZmZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpbmdpZnlCaWdJbnRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaWdJbnRVdGlsc18xLnN0cmluZ2lmeUJpZ0ludHM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1bnN0cmluZ2lmeUJpZ0ludHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpZ0ludFV0aWxzXzEudW5zdHJpbmdpZnlCaWdJbnRzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVlcENvcHlCaWdJbnRBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlnSW50VXRpbHNfMS5kZWVwQ29weUJpZ0ludEFycmF5OyB9IH0pO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTk9USElOR19VUF9NWV9TTEVFVkVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLk5PVEhJTkdfVVBfTVlfU0xFRVZFOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU05BUktfRklFTERfU0laRVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRzXzEuU05BUktfRklFTERfU0laRTsgfSB9KTtcbnZhciBrZXlzXzEgPSByZXF1aXJlKFwiLi9rZXlzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2VuUHJpdktleVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ga2V5c18xLmdlblByaXZLZXk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZW5SYW5kb21TYWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBrZXlzXzEuZ2VuUmFuZG9tU2FsdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZvcm1hdFByaXZLZXlGb3JCYWJ5SnViXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBrZXlzXzEuZm9ybWF0UHJpdktleUZvckJhYnlKdWI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZW5QdWJLZXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGtleXNfMS5nZW5QdWJLZXk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZW5LZXlwYWlyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBrZXlzXzEuZ2VuS2V5cGFpcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdlbkVjZGhTaGFyZWRLZXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGtleXNfMS5nZW5FY2RoU2hhcmVkS2V5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFja1B1YktleVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ga2V5c18xLnBhY2tQdWJLZXk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1bnBhY2tQdWJLZXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGtleXNfMS51bnBhY2tQdWJLZXk7IH0gfSk7XG52YXIgYmFieWp1Yl8xID0gcmVxdWlyZShcIi4vYmFieWp1YlwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkcxUG9pbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhYnlqdWJfMS5HMVBvaW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRzJQb2ludFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFieWp1Yl8xLkcyUG9pbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZW5SYW5kb21CYWJ5SnViVmFsdWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhYnlqdWJfMS5nZW5SYW5kb21CYWJ5SnViVmFsdWU7IH0gfSk7XG52YXIgaGFzaGluZ18xID0gcmVxdWlyZShcIi4vaGFzaGluZ1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNoYTI1Nkhhc2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc2hpbmdfMS5zaGEyNTZIYXNoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGFzaExlZnRSaWdodFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzaGluZ18xLmhhc2hMZWZ0UmlnaHQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoYXNoTlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzaGluZ18xLmhhc2hOOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGFzaDJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc2hpbmdfMS5oYXNoMjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhhc2gzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNoaW5nXzEuaGFzaDM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoYXNoNFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzaGluZ18xLmhhc2g0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGFzaDVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc2hpbmdfMS5oYXNoNTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhhc2gxMlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzaGluZ18xLmhhc2gxMjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhhc2hPbmVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc2hpbmdfMS5oYXNoT25lOyB9IH0pO1xudmFyIGJhYnlfanVianViXzEgPSByZXF1aXJlKFwiQHprLWtpdC9iYWJ5LWp1Ymp1YlwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImluQ3VydmVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhYnlfanVianViXzEuaW5DdXJ2ZTsgfSB9KTtcbnZhciBwb3NlaWRvbl9jaXBoZXJfMSA9IHJlcXVpcmUoXCJAemsta2l0L3Bvc2VpZG9uLWNpcGhlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBvc2VpZG9uRGVjcnlwdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcG9zZWlkb25fY2lwaGVyXzEucG9zZWlkb25EZWNyeXB0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicG9zZWlkb25EZWNyeXB0V2l0aG91dENoZWNrXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwb3NlaWRvbl9jaXBoZXJfMS5wb3NlaWRvbkRlY3J5cHRXaXRob3V0Q2hlY2s7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwb3NlaWRvbkVuY3J5cHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBvc2VpZG9uX2NpcGhlcl8xLnBvc2VpZG9uRW5jcnlwdDsgfSB9KTtcbnZhciBlZGRzYV9wb3NlaWRvbl8xID0gcmVxdWlyZShcIkB6ay1raXQvZWRkc2EtcG9zZWlkb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2ZXJpZnlTaWduYXR1cmVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVkZHNhX3Bvc2VpZG9uXzEudmVyaWZ5U2lnbmF0dXJlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2lnblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZWRkc2FfcG9zZWlkb25fMS5zaWduTWVzc2FnZTsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maci-crypto/build/ts/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maci-crypto/build/ts/keys.js":
/*!***************************************************!*\
  !*** ./node_modules/maci-crypto/build/ts/keys.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.genEcdhSharedKey = exports.genKeypair = exports.genPubKey = exports.unpackPubKey = exports.packPubKey = exports.formatPrivKeyForBabyJub = exports.genRandomSalt = exports.genPrivKey = void 0;\nconst baby_jubjub_1 = __webpack_require__(/*! @zk-kit/baby-jubjub */ \"(ssr)/./node_modules/@zk-kit/baby-jubjub/dist/index.cjs\");\nconst eddsa_poseidon_1 = __webpack_require__(/*! @zk-kit/eddsa-poseidon */ \"(ssr)/./node_modules/@zk-kit/eddsa-poseidon/dist/index.cjs\");\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nconst babyjub_1 = __webpack_require__(/*! ./babyjub */ \"(ssr)/./node_modules/maci-crypto/build/ts/babyjub.js\");\n/**\n * Generate a private key\n * @returns A random seed for a private key.\n */\nconst genPrivKey = () => BigInt(`0x${(0, crypto_1.randomBytes)(32).toString(\"hex\")}`);\nexports.genPrivKey = genPrivKey;\n/**\n * Generate a random value\n * @returns A BabyJub-compatible salt.\n */\nconst genRandomSalt = () => (0, babyjub_1.genRandomBabyJubValue)();\nexports.genRandomSalt = genRandomSalt;\n/**\n * An internal function which formats a random private key to be compatible\n * with the BabyJub curve. This is the format which should be passed into the\n * PubKey and other circuits.\n * @param privKey A private key generated using genPrivKey()\n * @returns A BabyJub-compatible private key.\n */\nconst formatPrivKeyForBabyJub = (privKey) => BigInt((0, eddsa_poseidon_1.deriveSecretScalar)(privKey.toString()));\nexports.formatPrivKeyForBabyJub = formatPrivKeyForBabyJub;\n/**\n * Losslessly reduces the size of the representation of a public key\n * @param pubKey The public key to pack\n * @returns A packed public key\n */\nconst packPubKey = (pubKey) => BigInt((0, eddsa_poseidon_1.packPublicKey)(pubKey));\nexports.packPubKey = packPubKey;\n/**\n * Restores the original PubKey from its packed representation\n * @param packed The value to unpack\n * @returns The unpacked public key\n */\nconst unpackPubKey = (packed) => {\n    const pubKey = (0, eddsa_poseidon_1.unpackPublicKey)(packed);\n    return pubKey.map((x) => BigInt(x));\n};\nexports.unpackPubKey = unpackPubKey;\n/**\n * @param privKey A private key generated using genPrivKey()\n * @returns A public key associated with the private key\n */\nconst genPubKey = (privKey) => {\n    const key = (0, eddsa_poseidon_1.derivePublicKey)(privKey.toString());\n    return [BigInt(key[0]), BigInt(key[1])];\n};\nexports.genPubKey = genPubKey;\n/**\n * Generates a keypair.\n * @returns a keypair\n */\nconst genKeypair = () => {\n    const privKey = (0, exports.genPrivKey)();\n    const pubKey = (0, exports.genPubKey)(privKey);\n    const keypair = { privKey, pubKey };\n    return keypair;\n};\nexports.genKeypair = genKeypair;\n/**\n * Generates an Elliptic-Curve Diffie–Hellman (ECDH) shared key given a private\n * key and a public key.\n * @param privKey A private key generated using genPrivKey()\n * @param pubKey A public key generated using genPubKey()\n * @returns The ECDH shared key.\n */\nconst genEcdhSharedKey = (privKey, pubKey) => (0, baby_jubjub_1.mulPointEscalar)(pubKey, (0, exports.formatPrivKeyForBabyJub)(privKey));\nexports.genEcdhSharedKey = genEcdhSharedKey;\n//# sourceMappingURL=keys.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFjaS1jcnlwdG8vYnVpbGQvdHMva2V5cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyxrQkFBa0IsR0FBRyxpQkFBaUIsR0FBRyxvQkFBb0IsR0FBRyxrQkFBa0IsR0FBRywrQkFBK0IsR0FBRyxxQkFBcUIsR0FBRyxrQkFBa0I7QUFDNUwsc0JBQXNCLG1CQUFPLENBQUMsb0ZBQXFCO0FBQ25ELHlCQUF5QixtQkFBTyxDQUFDLDBGQUF3QjtBQUN6RCxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyx1RUFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw4Q0FBOEM7QUFDbkYsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9tYWNpLWNyeXB0by9idWlsZC90cy9rZXlzLmpzPzJjNGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdlbkVjZGhTaGFyZWRLZXkgPSBleHBvcnRzLmdlbktleXBhaXIgPSBleHBvcnRzLmdlblB1YktleSA9IGV4cG9ydHMudW5wYWNrUHViS2V5ID0gZXhwb3J0cy5wYWNrUHViS2V5ID0gZXhwb3J0cy5mb3JtYXRQcml2S2V5Rm9yQmFieUp1YiA9IGV4cG9ydHMuZ2VuUmFuZG9tU2FsdCA9IGV4cG9ydHMuZ2VuUHJpdktleSA9IHZvaWQgMDtcbmNvbnN0IGJhYnlfanVianViXzEgPSByZXF1aXJlKFwiQHprLWtpdC9iYWJ5LWp1Ymp1YlwiKTtcbmNvbnN0IGVkZHNhX3Bvc2VpZG9uXzEgPSByZXF1aXJlKFwiQHprLWtpdC9lZGRzYS1wb3NlaWRvblwiKTtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbmNvbnN0IGJhYnlqdWJfMSA9IHJlcXVpcmUoXCIuL2JhYnlqdWJcIik7XG4vKipcbiAqIEdlbmVyYXRlIGEgcHJpdmF0ZSBrZXlcbiAqIEByZXR1cm5zIEEgcmFuZG9tIHNlZWQgZm9yIGEgcHJpdmF0ZSBrZXkuXG4gKi9cbmNvbnN0IGdlblByaXZLZXkgPSAoKSA9PiBCaWdJbnQoYDB4JHsoMCwgY3J5cHRvXzEucmFuZG9tQnl0ZXMpKDMyKS50b1N0cmluZyhcImhleFwiKX1gKTtcbmV4cG9ydHMuZ2VuUHJpdktleSA9IGdlblByaXZLZXk7XG4vKipcbiAqIEdlbmVyYXRlIGEgcmFuZG9tIHZhbHVlXG4gKiBAcmV0dXJucyBBIEJhYnlKdWItY29tcGF0aWJsZSBzYWx0LlxuICovXG5jb25zdCBnZW5SYW5kb21TYWx0ID0gKCkgPT4gKDAsIGJhYnlqdWJfMS5nZW5SYW5kb21CYWJ5SnViVmFsdWUpKCk7XG5leHBvcnRzLmdlblJhbmRvbVNhbHQgPSBnZW5SYW5kb21TYWx0O1xuLyoqXG4gKiBBbiBpbnRlcm5hbCBmdW5jdGlvbiB3aGljaCBmb3JtYXRzIGEgcmFuZG9tIHByaXZhdGUga2V5IHRvIGJlIGNvbXBhdGlibGVcbiAqIHdpdGggdGhlIEJhYnlKdWIgY3VydmUuIFRoaXMgaXMgdGhlIGZvcm1hdCB3aGljaCBzaG91bGQgYmUgcGFzc2VkIGludG8gdGhlXG4gKiBQdWJLZXkgYW5kIG90aGVyIGNpcmN1aXRzLlxuICogQHBhcmFtIHByaXZLZXkgQSBwcml2YXRlIGtleSBnZW5lcmF0ZWQgdXNpbmcgZ2VuUHJpdktleSgpXG4gKiBAcmV0dXJucyBBIEJhYnlKdWItY29tcGF0aWJsZSBwcml2YXRlIGtleS5cbiAqL1xuY29uc3QgZm9ybWF0UHJpdktleUZvckJhYnlKdWIgPSAocHJpdktleSkgPT4gQmlnSW50KCgwLCBlZGRzYV9wb3NlaWRvbl8xLmRlcml2ZVNlY3JldFNjYWxhcikocHJpdktleS50b1N0cmluZygpKSk7XG5leHBvcnRzLmZvcm1hdFByaXZLZXlGb3JCYWJ5SnViID0gZm9ybWF0UHJpdktleUZvckJhYnlKdWI7XG4vKipcbiAqIExvc3NsZXNzbHkgcmVkdWNlcyB0aGUgc2l6ZSBvZiB0aGUgcmVwcmVzZW50YXRpb24gb2YgYSBwdWJsaWMga2V5XG4gKiBAcGFyYW0gcHViS2V5IFRoZSBwdWJsaWMga2V5IHRvIHBhY2tcbiAqIEByZXR1cm5zIEEgcGFja2VkIHB1YmxpYyBrZXlcbiAqL1xuY29uc3QgcGFja1B1YktleSA9IChwdWJLZXkpID0+IEJpZ0ludCgoMCwgZWRkc2FfcG9zZWlkb25fMS5wYWNrUHVibGljS2V5KShwdWJLZXkpKTtcbmV4cG9ydHMucGFja1B1YktleSA9IHBhY2tQdWJLZXk7XG4vKipcbiAqIFJlc3RvcmVzIHRoZSBvcmlnaW5hbCBQdWJLZXkgZnJvbSBpdHMgcGFja2VkIHJlcHJlc2VudGF0aW9uXG4gKiBAcGFyYW0gcGFja2VkIFRoZSB2YWx1ZSB0byB1bnBhY2tcbiAqIEByZXR1cm5zIFRoZSB1bnBhY2tlZCBwdWJsaWMga2V5XG4gKi9cbmNvbnN0IHVucGFja1B1YktleSA9IChwYWNrZWQpID0+IHtcbiAgICBjb25zdCBwdWJLZXkgPSAoMCwgZWRkc2FfcG9zZWlkb25fMS51bnBhY2tQdWJsaWNLZXkpKHBhY2tlZCk7XG4gICAgcmV0dXJuIHB1YktleS5tYXAoKHgpID0+IEJpZ0ludCh4KSk7XG59O1xuZXhwb3J0cy51bnBhY2tQdWJLZXkgPSB1bnBhY2tQdWJLZXk7XG4vKipcbiAqIEBwYXJhbSBwcml2S2V5IEEgcHJpdmF0ZSBrZXkgZ2VuZXJhdGVkIHVzaW5nIGdlblByaXZLZXkoKVxuICogQHJldHVybnMgQSBwdWJsaWMga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJpdmF0ZSBrZXlcbiAqL1xuY29uc3QgZ2VuUHViS2V5ID0gKHByaXZLZXkpID0+IHtcbiAgICBjb25zdCBrZXkgPSAoMCwgZWRkc2FfcG9zZWlkb25fMS5kZXJpdmVQdWJsaWNLZXkpKHByaXZLZXkudG9TdHJpbmcoKSk7XG4gICAgcmV0dXJuIFtCaWdJbnQoa2V5WzBdKSwgQmlnSW50KGtleVsxXSldO1xufTtcbmV4cG9ydHMuZ2VuUHViS2V5ID0gZ2VuUHViS2V5O1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSBrZXlwYWlyLlxuICogQHJldHVybnMgYSBrZXlwYWlyXG4gKi9cbmNvbnN0IGdlbktleXBhaXIgPSAoKSA9PiB7XG4gICAgY29uc3QgcHJpdktleSA9ICgwLCBleHBvcnRzLmdlblByaXZLZXkpKCk7XG4gICAgY29uc3QgcHViS2V5ID0gKDAsIGV4cG9ydHMuZ2VuUHViS2V5KShwcml2S2V5KTtcbiAgICBjb25zdCBrZXlwYWlyID0geyBwcml2S2V5LCBwdWJLZXkgfTtcbiAgICByZXR1cm4ga2V5cGFpcjtcbn07XG5leHBvcnRzLmdlbktleXBhaXIgPSBnZW5LZXlwYWlyO1xuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gRWxsaXB0aWMtQ3VydmUgRGlmZmll4oCTSGVsbG1hbiAoRUNESCkgc2hhcmVkIGtleSBnaXZlbiBhIHByaXZhdGVcbiAqIGtleSBhbmQgYSBwdWJsaWMga2V5LlxuICogQHBhcmFtIHByaXZLZXkgQSBwcml2YXRlIGtleSBnZW5lcmF0ZWQgdXNpbmcgZ2VuUHJpdktleSgpXG4gKiBAcGFyYW0gcHViS2V5IEEgcHVibGljIGtleSBnZW5lcmF0ZWQgdXNpbmcgZ2VuUHViS2V5KClcbiAqIEByZXR1cm5zIFRoZSBFQ0RIIHNoYXJlZCBrZXkuXG4gKi9cbmNvbnN0IGdlbkVjZGhTaGFyZWRLZXkgPSAocHJpdktleSwgcHViS2V5KSA9PiAoMCwgYmFieV9qdWJqdWJfMS5tdWxQb2ludEVzY2FsYXIpKHB1YktleSwgKDAsIGV4cG9ydHMuZm9ybWF0UHJpdktleUZvckJhYnlKdWIpKHByaXZLZXkpKTtcbmV4cG9ydHMuZ2VuRWNkaFNoYXJlZEtleSA9IGdlbkVjZGhTaGFyZWRLZXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXlzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maci-crypto/build/ts/keys.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maci-crypto/build/ts/quinTree.js":
/*!*******************************************************!*\
  !*** ./node_modules/maci-crypto/build/ts/quinTree.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IncrementalQuinTree = void 0;\n/**\n * An implementation of an incremental Merkle tree\n * @dev adapted from https://github.com/weijiekoh/optimisedmt\n */\nclass IncrementalQuinTree {\n    /**\n     * Create a new instance of the MaciQuinTree\n     * @param depth The depth of the tree\n     * @param zeroValue The zero value of the tree\n     * @param arity The arity of the tree\n     * @param hashFunc The hash function of the tree\n     */\n    constructor(depth, zeroValue, arity, hashFunc) {\n        // The smallest empty leaf index\n        this.nextIndex = 0;\n        // Contains the zero value per level. i.e. zeros[0] is zeroValue,\n        // zeros[1] is the hash of leavesPerNode zeros, and so on.\n        this.zeros = [];\n        /**\n         * Verify a proof\n         * @param proof The proof to verify\n         * @returns Whether the proof is valid\n         */\n        this.verifyProof = (proof) => {\n            const { pathElements, leaf, root, pathIndices } = proof;\n            // Hash the first level\n            const firstLevel = pathElements[0].map(BigInt);\n            firstLevel.splice(Number(pathIndices[0]), 0, leaf);\n            let currentLevelHash = this.hashFunc(firstLevel);\n            // Verify the proof\n            for (let i = 1; i < pathElements.length; i += 1) {\n                const level = pathElements[i].map(BigInt);\n                level.splice(Number(pathIndices[i]), 0, currentLevelHash);\n                currentLevelHash = this.hashFunc(level);\n            }\n            // the path is valid if the root matches the calculated root\n            return currentLevelHash === root;\n        };\n        /**\n         * Calculate the zeroes and the root of a tree\n         * @param arity The arity of the tree\n         * @param depth The depth of the tree\n         * @param zeroValue The zero value of the tree\n         * @param hashFunc The hash function of the tree\n         * @returns The zeros and the root\n         */\n        this.calcInitialVals = (arity, depth, zeroValue, hashFunc) => {\n            const zeros = [];\n            let currentLevelHash = zeroValue;\n            for (let i = 0; i < depth; i += 1) {\n                zeros.push(currentLevelHash);\n                const z = Array(arity).fill(currentLevelHash);\n                currentLevelHash = hashFunc(z);\n            }\n            return { zeros, root: currentLevelHash };\n        };\n        this.depth = depth;\n        this.zeroValue = zeroValue;\n        this.arity = arity;\n        this.hashFunc = hashFunc;\n        // calculate the initial values\n        const { zeros, root } = this.calcInitialVals(this.arity, this.depth, this.zeroValue, this.hashFunc);\n        this.zeros = zeros;\n        this.root = root;\n        // calculate the number of nodes\n        this.numNodes = (this.arity ** (this.depth + 1) - 1) / (this.arity - 1);\n        // initialize the nodes\n        this.nodes = {};\n        // set the root node\n        this.nodes[this.numNodes - 1] = root;\n        // calculate the capacity\n        this.capacity = this.arity ** this.depth;\n    }\n    /**\n     * Insert a leaf at the next available index\n     * @param value The value to insert\n     */\n    insert(value) {\n        // update the node with this leaf\n        this.update(this.nextIndex, value);\n        this.nextIndex += 1;\n    }\n    /**\n     * Update a leaf at a given index\n     * @param index The index of the leaf to update\n     * @param value The value to update the leaf with\n     */\n    update(index, value) {\n        // Set the leaf value\n        this.setNode(index, value);\n        // Set the parent leaf value\n        // Get the parent indices\n        const parentIndices = this.calcParentIndices(index);\n        parentIndices.forEach((parentIndex) => {\n            const childIndices = this.calcChildIndices(parentIndex);\n            const elements = [];\n            childIndices.forEach((childIndex) => {\n                elements.push(this.getNode(childIndex));\n            });\n            this.nodes[parentIndex] = this.hashFunc(elements);\n        });\n        this.root = this.nodes[this.numNodes - 1];\n    }\n    /**\n     * Calculate the indices of the leaves in the path to the root\n     * @param index The index of the leaf\n     * @returns The indices of the leaves in the path to the root\n     */\n    calcLeafIndices(index) {\n        const indices = new Array(this.depth);\n        let r = index;\n        for (let i = 0; i < this.depth; i += 1) {\n            indices[i] = r % this.arity;\n            r = Math.floor(r / this.arity);\n        }\n        return indices;\n    }\n    /**\n     * Generate a proof for a given leaf index\n     * @param index The index of the leaf to generate a proof for\n     * @returns The proof\n     */\n    genProof(index) {\n        if (index < 0) {\n            throw new Error(\"The leaf index must be greater or equal to 0\");\n        }\n        if (index >= this.capacity) {\n            throw new Error(\"The leaf index must be less than the tree capacity\");\n        }\n        const pathElements = [];\n        const indices = this.calcLeafIndices(index);\n        // Calculate path elements\n        let leafIndex = index;\n        let offset = 0;\n        for (let i = 0; i < this.depth; i += 1) {\n            const elements = [];\n            const start = leafIndex - (leafIndex % this.arity) + offset;\n            for (let j = 0; j < this.arity; j += 1) {\n                if (j !== indices[i]) {\n                    const node = this.getNode(start + j);\n                    elements.push(node);\n                }\n            }\n            pathElements.push(elements);\n            leafIndex = Math.floor(leafIndex / this.arity);\n            offset += this.arity ** (this.depth - i);\n        }\n        return {\n            pathElements,\n            pathIndices: indices,\n            root: this.root,\n            leaf: this.getNode(index),\n        };\n    }\n    /**\n     * Generates a Merkle proof from a subroot to the root.\n     * @param startIndex The index of the first leaf\n     * @param endIndex The index of the last leaf\n     * @returns The Merkle proof\n     */\n    genSubrootProof(\n    // inclusive\n    startIndex, \n    // exclusive\n    endIndex) {\n        // The end index must be greater than the start index\n        if (startIndex >= endIndex) {\n            throw new Error(\"The start index must be less than the end index\");\n        }\n        if (startIndex < 0) {\n            throw new Error(\"The start index must be greater or equal to 0\");\n        }\n        // count the number of leaves\n        const numLeaves = endIndex - startIndex;\n        // The number of leaves must be a multiple of the tree arity\n        if (numLeaves % this.arity !== 0) {\n            throw new Error(\"The number of leaves must be a multiple of the tree arity\");\n        }\n        // The number of leaves must be lower than the maximum tree capacity\n        if (numLeaves >= this.capacity) {\n            throw new Error(\"The number of leaves must be less than the tree capacity\");\n        }\n        // Calculate the subdepth\n        let subDepth = 0;\n        while (numLeaves !== this.arity ** subDepth && subDepth < this.depth) {\n            subDepth += 1;\n        }\n        const subTree = new IncrementalQuinTree(subDepth, this.zeroValue, this.arity, this.hashFunc);\n        for (let i = startIndex; i < endIndex; i += 1) {\n            subTree.insert(this.getNode(i));\n        }\n        const fullPath = this.genProof(startIndex);\n        fullPath.pathIndices = fullPath.pathIndices.slice(subDepth, this.depth);\n        fullPath.pathElements = fullPath.pathElements.slice(subDepth, this.depth);\n        fullPath.leaf = subTree.root;\n        return fullPath;\n    }\n    /**\n     * Calculate the indices of the parent\n     * @param index The index of the leaf\n     * @returns The indices of the parent\n     */\n    calcParentIndices(index) {\n        // can only calculate the parent for leaves not subroots\n        if (index >= this.capacity || index < 0) {\n            throw new Error(`Index ${index} is out of bounds. Can only get parents of leaves`);\n        }\n        const indices = new Array(this.depth);\n        let r = index;\n        let levelCapacity = 0;\n        for (let i = 0; i < this.depth; i += 1) {\n            levelCapacity += this.arity ** (this.depth - i);\n            r = Math.floor(r / this.arity);\n            indices.push(levelCapacity + r);\n        }\n        return indices;\n    }\n    /**\n     * Calculate the indices of the children of a node\n     * @param index The index of the node\n     * @returns The indices of the children\n     */\n    calcChildIndices(index) {\n        // cannot get the children of a leaf\n        if (index < this.capacity || index < 0) {\n            throw new Error(`Index ${index} is out of bounds. Can only get children of subroots`);\n        }\n        // find the level\n        let level = 0;\n        let r = this.arity ** level;\n        do {\n            level += 1;\n            r += this.arity ** level;\n        } while (index >= r);\n        const start = (index - this.arity ** level) * this.arity;\n        const indices = Array(this.arity)\n            .fill(0)\n            .map((_, i) => start + i);\n        return indices;\n    }\n    /**\n     * Get a node at a given index\n     * @param index The index of the node\n     * @returns The node\n     */\n    getNode(index) {\n        // if we have it, just return it\n        if (this.nodes[index]) {\n            return this.nodes[index];\n        }\n        // find the zero value at that level\n        // first need to find the level\n        let runningTotal = 0;\n        let level = this.depth;\n        while (level >= 0) {\n            runningTotal += this.arity ** level;\n            if (index < runningTotal) {\n                break;\n            }\n            level -= 1;\n        }\n        return this.zeros[this.depth - level];\n    }\n    /**\n     * Set a node (not the root)\n     * @param index the index of the node\n     * @param value the value of the node\n     */\n    setNode(index, value) {\n        if (index > this.numNodes - 1 || index < 0) {\n            throw new Error(\"Index out of bounds\");\n        }\n        this.nodes[index] = value;\n    }\n    /**\n     * Copy the tree to a new instance\n     * @returns The new instance\n     */\n    copy() {\n        const newTree = new IncrementalQuinTree(this.depth, this.zeroValue, this.arity, this.hashFunc);\n        newTree.nodes = this.nodes;\n        newTree.numNodes = this.numNodes;\n        newTree.zeros = this.zeros;\n        newTree.root = this.root;\n        newTree.nextIndex = this.nextIndex;\n        return newTree;\n    }\n}\nexports.IncrementalQuinTree = IncrementalQuinTree;\n//# sourceMappingURL=quinTree.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFjaS1jcnlwdG8vYnVpbGQvdHMvcXVpblRyZWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3Q0FBd0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL21hY2ktY3J5cHRvL2J1aWxkL3RzL3F1aW5UcmVlLmpzPzk2MWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkluY3JlbWVudGFsUXVpblRyZWUgPSB2b2lkIDA7XG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGFuIGluY3JlbWVudGFsIE1lcmtsZSB0cmVlXG4gKiBAZGV2IGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vd2Vpamlla29oL29wdGltaXNlZG10XG4gKi9cbmNsYXNzIEluY3JlbWVudGFsUXVpblRyZWUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgTWFjaVF1aW5UcmVlXG4gICAgICogQHBhcmFtIGRlcHRoIFRoZSBkZXB0aCBvZiB0aGUgdHJlZVxuICAgICAqIEBwYXJhbSB6ZXJvVmFsdWUgVGhlIHplcm8gdmFsdWUgb2YgdGhlIHRyZWVcbiAgICAgKiBAcGFyYW0gYXJpdHkgVGhlIGFyaXR5IG9mIHRoZSB0cmVlXG4gICAgICogQHBhcmFtIGhhc2hGdW5jIFRoZSBoYXNoIGZ1bmN0aW9uIG9mIHRoZSB0cmVlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZGVwdGgsIHplcm9WYWx1ZSwgYXJpdHksIGhhc2hGdW5jKSB7XG4gICAgICAgIC8vIFRoZSBzbWFsbGVzdCBlbXB0eSBsZWFmIGluZGV4XG4gICAgICAgIHRoaXMubmV4dEluZGV4ID0gMDtcbiAgICAgICAgLy8gQ29udGFpbnMgdGhlIHplcm8gdmFsdWUgcGVyIGxldmVsLiBpLmUuIHplcm9zWzBdIGlzIHplcm9WYWx1ZSxcbiAgICAgICAgLy8gemVyb3NbMV0gaXMgdGhlIGhhc2ggb2YgbGVhdmVzUGVyTm9kZSB6ZXJvcywgYW5kIHNvIG9uLlxuICAgICAgICB0aGlzLnplcm9zID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZnkgYSBwcm9vZlxuICAgICAgICAgKiBAcGFyYW0gcHJvb2YgVGhlIHByb29mIHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBwcm9vZiBpcyB2YWxpZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52ZXJpZnlQcm9vZiA9IChwcm9vZikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwYXRoRWxlbWVudHMsIGxlYWYsIHJvb3QsIHBhdGhJbmRpY2VzIH0gPSBwcm9vZjtcbiAgICAgICAgICAgIC8vIEhhc2ggdGhlIGZpcnN0IGxldmVsXG4gICAgICAgICAgICBjb25zdCBmaXJzdExldmVsID0gcGF0aEVsZW1lbnRzWzBdLm1hcChCaWdJbnQpO1xuICAgICAgICAgICAgZmlyc3RMZXZlbC5zcGxpY2UoTnVtYmVyKHBhdGhJbmRpY2VzWzBdKSwgMCwgbGVhZik7XG4gICAgICAgICAgICBsZXQgY3VycmVudExldmVsSGFzaCA9IHRoaXMuaGFzaEZ1bmMoZmlyc3RMZXZlbCk7XG4gICAgICAgICAgICAvLyBWZXJpZnkgdGhlIHByb29mXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhdGhFbGVtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxldmVsID0gcGF0aEVsZW1lbnRzW2ldLm1hcChCaWdJbnQpO1xuICAgICAgICAgICAgICAgIGxldmVsLnNwbGljZShOdW1iZXIocGF0aEluZGljZXNbaV0pLCAwLCBjdXJyZW50TGV2ZWxIYXNoKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGV2ZWxIYXNoID0gdGhpcy5oYXNoRnVuYyhsZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGUgcGF0aCBpcyB2YWxpZCBpZiB0aGUgcm9vdCBtYXRjaGVzIHRoZSBjYWxjdWxhdGVkIHJvb3RcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWxIYXNoID09PSByb290O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlIHRoZSB6ZXJvZXMgYW5kIHRoZSByb290IG9mIGEgdHJlZVxuICAgICAgICAgKiBAcGFyYW0gYXJpdHkgVGhlIGFyaXR5IG9mIHRoZSB0cmVlXG4gICAgICAgICAqIEBwYXJhbSBkZXB0aCBUaGUgZGVwdGggb2YgdGhlIHRyZWVcbiAgICAgICAgICogQHBhcmFtIHplcm9WYWx1ZSBUaGUgemVybyB2YWx1ZSBvZiB0aGUgdHJlZVxuICAgICAgICAgKiBAcGFyYW0gaGFzaEZ1bmMgVGhlIGhhc2ggZnVuY3Rpb24gb2YgdGhlIHRyZWVcbiAgICAgICAgICogQHJldHVybnMgVGhlIHplcm9zIGFuZCB0aGUgcm9vdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYWxjSW5pdGlhbFZhbHMgPSAoYXJpdHksIGRlcHRoLCB6ZXJvVmFsdWUsIGhhc2hGdW5jKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB6ZXJvcyA9IFtdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRMZXZlbEhhc2ggPSB6ZXJvVmFsdWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHRoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB6ZXJvcy5wdXNoKGN1cnJlbnRMZXZlbEhhc2gpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHogPSBBcnJheShhcml0eSkuZmlsbChjdXJyZW50TGV2ZWxIYXNoKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGV2ZWxIYXNoID0gaGFzaEZ1bmMoeik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyB6ZXJvcywgcm9vdDogY3VycmVudExldmVsSGFzaCB9O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgICAgIHRoaXMuemVyb1ZhbHVlID0gemVyb1ZhbHVlO1xuICAgICAgICB0aGlzLmFyaXR5ID0gYXJpdHk7XG4gICAgICAgIHRoaXMuaGFzaEZ1bmMgPSBoYXNoRnVuYztcbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBpbml0aWFsIHZhbHVlc1xuICAgICAgICBjb25zdCB7IHplcm9zLCByb290IH0gPSB0aGlzLmNhbGNJbml0aWFsVmFscyh0aGlzLmFyaXR5LCB0aGlzLmRlcHRoLCB0aGlzLnplcm9WYWx1ZSwgdGhpcy5oYXNoRnVuYyk7XG4gICAgICAgIHRoaXMuemVyb3MgPSB6ZXJvcztcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBudW1iZXIgb2Ygbm9kZXNcbiAgICAgICAgdGhpcy5udW1Ob2RlcyA9ICh0aGlzLmFyaXR5ICoqICh0aGlzLmRlcHRoICsgMSkgLSAxKSAvICh0aGlzLmFyaXR5IC0gMSk7XG4gICAgICAgIC8vIGluaXRpYWxpemUgdGhlIG5vZGVzXG4gICAgICAgIHRoaXMubm9kZXMgPSB7fTtcbiAgICAgICAgLy8gc2V0IHRoZSByb290IG5vZGVcbiAgICAgICAgdGhpcy5ub2Rlc1t0aGlzLm51bU5vZGVzIC0gMV0gPSByb290O1xuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGNhcGFjaXR5XG4gICAgICAgIHRoaXMuY2FwYWNpdHkgPSB0aGlzLmFyaXR5ICoqIHRoaXMuZGVwdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIGxlYWYgYXQgdGhlIG5leHQgYXZhaWxhYmxlIGluZGV4XG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNlcnRcbiAgICAgKi9cbiAgICBpbnNlcnQodmFsdWUpIHtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBub2RlIHdpdGggdGhpcyBsZWFmXG4gICAgICAgIHRoaXMudXBkYXRlKHRoaXMubmV4dEluZGV4LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMubmV4dEluZGV4ICs9IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhIGxlYWYgYXQgYSBnaXZlbiBpbmRleFxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGxlYWYgdG8gdXBkYXRlXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byB1cGRhdGUgdGhlIGxlYWYgd2l0aFxuICAgICAqL1xuICAgIHVwZGF0ZShpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgLy8gU2V0IHRoZSBsZWFmIHZhbHVlXG4gICAgICAgIHRoaXMuc2V0Tm9kZShpbmRleCwgdmFsdWUpO1xuICAgICAgICAvLyBTZXQgdGhlIHBhcmVudCBsZWFmIHZhbHVlXG4gICAgICAgIC8vIEdldCB0aGUgcGFyZW50IGluZGljZXNcbiAgICAgICAgY29uc3QgcGFyZW50SW5kaWNlcyA9IHRoaXMuY2FsY1BhcmVudEluZGljZXMoaW5kZXgpO1xuICAgICAgICBwYXJlbnRJbmRpY2VzLmZvckVhY2goKHBhcmVudEluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZEluZGljZXMgPSB0aGlzLmNhbGNDaGlsZEluZGljZXMocGFyZW50SW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIGNoaWxkSW5kaWNlcy5mb3JFYWNoKChjaGlsZEluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaCh0aGlzLmdldE5vZGUoY2hpbGRJbmRleCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzW3BhcmVudEluZGV4XSA9IHRoaXMuaGFzaEZ1bmMoZWxlbWVudHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5ub2Rlc1t0aGlzLm51bU5vZGVzIC0gMV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgaW5kaWNlcyBvZiB0aGUgbGVhdmVzIGluIHRoZSBwYXRoIHRvIHRoZSByb290XG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbGVhZlxuICAgICAqIEByZXR1cm5zIFRoZSBpbmRpY2VzIG9mIHRoZSBsZWF2ZXMgaW4gdGhlIHBhdGggdG8gdGhlIHJvb3RcbiAgICAgKi9cbiAgICBjYWxjTGVhZkluZGljZXMoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IG5ldyBBcnJheSh0aGlzLmRlcHRoKTtcbiAgICAgICAgbGV0IHIgPSBpbmRleDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRlcHRoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGluZGljZXNbaV0gPSByICUgdGhpcy5hcml0eTtcbiAgICAgICAgICAgIHIgPSBNYXRoLmZsb29yKHIgLyB0aGlzLmFyaXR5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kaWNlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSBwcm9vZiBmb3IgYSBnaXZlbiBsZWFmIGluZGV4XG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbGVhZiB0byBnZW5lcmF0ZSBhIHByb29mIGZvclxuICAgICAqIEByZXR1cm5zIFRoZSBwcm9vZlxuICAgICAqL1xuICAgIGdlblByb29mKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBsZWFmIGluZGV4IG11c3QgYmUgZ3JlYXRlciBvciBlcXVhbCB0byAwXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA+PSB0aGlzLmNhcGFjaXR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbGVhZiBpbmRleCBtdXN0IGJlIGxlc3MgdGhhbiB0aGUgdHJlZSBjYXBhY2l0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXRoRWxlbWVudHMgPSBbXTtcbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IHRoaXMuY2FsY0xlYWZJbmRpY2VzKGluZGV4KTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHBhdGggZWxlbWVudHNcbiAgICAgICAgbGV0IGxlYWZJbmRleCA9IGluZGV4O1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRlcHRoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGxlYWZJbmRleCAtIChsZWFmSW5kZXggJSB0aGlzLmFyaXR5KSArIG9mZnNldDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5hcml0eTsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGogIT09IGluZGljZXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0Tm9kZShzdGFydCArIGopO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGhFbGVtZW50cy5wdXNoKGVsZW1lbnRzKTtcbiAgICAgICAgICAgIGxlYWZJbmRleCA9IE1hdGguZmxvb3IobGVhZkluZGV4IC8gdGhpcy5hcml0eSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gdGhpcy5hcml0eSAqKiAodGhpcy5kZXB0aCAtIGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXRoRWxlbWVudHMsXG4gICAgICAgICAgICBwYXRoSW5kaWNlczogaW5kaWNlcyxcbiAgICAgICAgICAgIHJvb3Q6IHRoaXMucm9vdCxcbiAgICAgICAgICAgIGxlYWY6IHRoaXMuZ2V0Tm9kZShpbmRleCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIE1lcmtsZSBwcm9vZiBmcm9tIGEgc3Vicm9vdCB0byB0aGUgcm9vdC5cbiAgICAgKiBAcGFyYW0gc3RhcnRJbmRleCBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGxlYWZcbiAgICAgKiBAcGFyYW0gZW5kSW5kZXggVGhlIGluZGV4IG9mIHRoZSBsYXN0IGxlYWZcbiAgICAgKiBAcmV0dXJucyBUaGUgTWVya2xlIHByb29mXG4gICAgICovXG4gICAgZ2VuU3Vicm9vdFByb29mKFxuICAgIC8vIGluY2x1c2l2ZVxuICAgIHN0YXJ0SW5kZXgsIFxuICAgIC8vIGV4Y2x1c2l2ZVxuICAgIGVuZEluZGV4KSB7XG4gICAgICAgIC8vIFRoZSBlbmQgaW5kZXggbXVzdCBiZSBncmVhdGVyIHRoYW4gdGhlIHN0YXJ0IGluZGV4XG4gICAgICAgIGlmIChzdGFydEluZGV4ID49IGVuZEluZGV4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3RhcnQgaW5kZXggbXVzdCBiZSBsZXNzIHRoYW4gdGhlIGVuZCBpbmRleFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdGFydCBpbmRleCBtdXN0IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIGxlYXZlc1xuICAgICAgICBjb25zdCBudW1MZWF2ZXMgPSBlbmRJbmRleCAtIHN0YXJ0SW5kZXg7XG4gICAgICAgIC8vIFRoZSBudW1iZXIgb2YgbGVhdmVzIG11c3QgYmUgYSBtdWx0aXBsZSBvZiB0aGUgdHJlZSBhcml0eVxuICAgICAgICBpZiAobnVtTGVhdmVzICUgdGhpcy5hcml0eSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIG51bWJlciBvZiBsZWF2ZXMgbXVzdCBiZSBhIG11bHRpcGxlIG9mIHRoZSB0cmVlIGFyaXR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBudW1iZXIgb2YgbGVhdmVzIG11c3QgYmUgbG93ZXIgdGhhbiB0aGUgbWF4aW11bSB0cmVlIGNhcGFjaXR5XG4gICAgICAgIGlmIChudW1MZWF2ZXMgPj0gdGhpcy5jYXBhY2l0eSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIG51bWJlciBvZiBsZWF2ZXMgbXVzdCBiZSBsZXNzIHRoYW4gdGhlIHRyZWUgY2FwYWNpdHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBzdWJkZXB0aFxuICAgICAgICBsZXQgc3ViRGVwdGggPSAwO1xuICAgICAgICB3aGlsZSAobnVtTGVhdmVzICE9PSB0aGlzLmFyaXR5ICoqIHN1YkRlcHRoICYmIHN1YkRlcHRoIDwgdGhpcy5kZXB0aCkge1xuICAgICAgICAgICAgc3ViRGVwdGggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJUcmVlID0gbmV3IEluY3JlbWVudGFsUXVpblRyZWUoc3ViRGVwdGgsIHRoaXMuemVyb1ZhbHVlLCB0aGlzLmFyaXR5LCB0aGlzLmhhc2hGdW5jKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSArPSAxKSB7XG4gICAgICAgICAgICBzdWJUcmVlLmluc2VydCh0aGlzLmdldE5vZGUoaSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gdGhpcy5nZW5Qcm9vZihzdGFydEluZGV4KTtcbiAgICAgICAgZnVsbFBhdGgucGF0aEluZGljZXMgPSBmdWxsUGF0aC5wYXRoSW5kaWNlcy5zbGljZShzdWJEZXB0aCwgdGhpcy5kZXB0aCk7XG4gICAgICAgIGZ1bGxQYXRoLnBhdGhFbGVtZW50cyA9IGZ1bGxQYXRoLnBhdGhFbGVtZW50cy5zbGljZShzdWJEZXB0aCwgdGhpcy5kZXB0aCk7XG4gICAgICAgIGZ1bGxQYXRoLmxlYWYgPSBzdWJUcmVlLnJvb3Q7XG4gICAgICAgIHJldHVybiBmdWxsUGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBpbmRpY2VzIG9mIHRoZSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBsZWFmXG4gICAgICogQHJldHVybnMgVGhlIGluZGljZXMgb2YgdGhlIHBhcmVudFxuICAgICAqL1xuICAgIGNhbGNQYXJlbnRJbmRpY2VzKGluZGV4KSB7XG4gICAgICAgIC8vIGNhbiBvbmx5IGNhbGN1bGF0ZSB0aGUgcGFyZW50IGZvciBsZWF2ZXMgbm90IHN1YnJvb3RzXG4gICAgICAgIGlmIChpbmRleCA+PSB0aGlzLmNhcGFjaXR5IHx8IGluZGV4IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbmRleCAke2luZGV4fSBpcyBvdXQgb2YgYm91bmRzLiBDYW4gb25seSBnZXQgcGFyZW50cyBvZiBsZWF2ZXNgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRpY2VzID0gbmV3IEFycmF5KHRoaXMuZGVwdGgpO1xuICAgICAgICBsZXQgciA9IGluZGV4O1xuICAgICAgICBsZXQgbGV2ZWxDYXBhY2l0eSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kZXB0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBsZXZlbENhcGFjaXR5ICs9IHRoaXMuYXJpdHkgKiogKHRoaXMuZGVwdGggLSBpKTtcbiAgICAgICAgICAgIHIgPSBNYXRoLmZsb29yKHIgLyB0aGlzLmFyaXR5KTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaChsZXZlbENhcGFjaXR5ICsgcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGljZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgaW5kaWNlcyBvZiB0aGUgY2hpbGRyZW4gb2YgYSBub2RlXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZVxuICAgICAqIEByZXR1cm5zIFRoZSBpbmRpY2VzIG9mIHRoZSBjaGlsZHJlblxuICAgICAqL1xuICAgIGNhbGNDaGlsZEluZGljZXMoaW5kZXgpIHtcbiAgICAgICAgLy8gY2Fubm90IGdldCB0aGUgY2hpbGRyZW4gb2YgYSBsZWFmXG4gICAgICAgIGlmIChpbmRleCA8IHRoaXMuY2FwYWNpdHkgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluZGV4ICR7aW5kZXh9IGlzIG91dCBvZiBib3VuZHMuIENhbiBvbmx5IGdldCBjaGlsZHJlbiBvZiBzdWJyb290c2ApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpbmQgdGhlIGxldmVsXG4gICAgICAgIGxldCBsZXZlbCA9IDA7XG4gICAgICAgIGxldCByID0gdGhpcy5hcml0eSAqKiBsZXZlbDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGV2ZWwgKz0gMTtcbiAgICAgICAgICAgIHIgKz0gdGhpcy5hcml0eSAqKiBsZXZlbDtcbiAgICAgICAgfSB3aGlsZSAoaW5kZXggPj0gcik7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gKGluZGV4IC0gdGhpcy5hcml0eSAqKiBsZXZlbCkgKiB0aGlzLmFyaXR5O1xuICAgICAgICBjb25zdCBpbmRpY2VzID0gQXJyYXkodGhpcy5hcml0eSlcbiAgICAgICAgICAgIC5maWxsKDApXG4gICAgICAgICAgICAubWFwKChfLCBpKSA9PiBzdGFydCArIGkpO1xuICAgICAgICByZXR1cm4gaW5kaWNlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgbm9kZSBhdCBhIGdpdmVuIGluZGV4XG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZVxuICAgICAqIEByZXR1cm5zIFRoZSBub2RlXG4gICAgICovXG4gICAgZ2V0Tm9kZShpbmRleCkge1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGl0LCBqdXN0IHJldHVybiBpdFxuICAgICAgICBpZiAodGhpcy5ub2Rlc1tpbmRleF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaW5kIHRoZSB6ZXJvIHZhbHVlIGF0IHRoYXQgbGV2ZWxcbiAgICAgICAgLy8gZmlyc3QgbmVlZCB0byBmaW5kIHRoZSBsZXZlbFxuICAgICAgICBsZXQgcnVubmluZ1RvdGFsID0gMDtcbiAgICAgICAgbGV0IGxldmVsID0gdGhpcy5kZXB0aDtcbiAgICAgICAgd2hpbGUgKGxldmVsID49IDApIHtcbiAgICAgICAgICAgIHJ1bm5pbmdUb3RhbCArPSB0aGlzLmFyaXR5ICoqIGxldmVsO1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgcnVubmluZ1RvdGFsKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXZlbCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnplcm9zW3RoaXMuZGVwdGggLSBsZXZlbF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBhIG5vZGUgKG5vdCB0aGUgcm9vdClcbiAgICAgKiBAcGFyYW0gaW5kZXggdGhlIGluZGV4IG9mIHRoZSBub2RlXG4gICAgICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSBvZiB0aGUgbm9kZVxuICAgICAqL1xuICAgIHNldE5vZGUoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpbmRleCA+IHRoaXMubnVtTm9kZXMgLSAxIHx8IGluZGV4IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGVzW2luZGV4XSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3B5IHRoZSB0cmVlIHRvIGEgbmV3IGluc3RhbmNlXG4gICAgICogQHJldHVybnMgVGhlIG5ldyBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvcHkoKSB7XG4gICAgICAgIGNvbnN0IG5ld1RyZWUgPSBuZXcgSW5jcmVtZW50YWxRdWluVHJlZSh0aGlzLmRlcHRoLCB0aGlzLnplcm9WYWx1ZSwgdGhpcy5hcml0eSwgdGhpcy5oYXNoRnVuYyk7XG4gICAgICAgIG5ld1RyZWUubm9kZXMgPSB0aGlzLm5vZGVzO1xuICAgICAgICBuZXdUcmVlLm51bU5vZGVzID0gdGhpcy5udW1Ob2RlcztcbiAgICAgICAgbmV3VHJlZS56ZXJvcyA9IHRoaXMuemVyb3M7XG4gICAgICAgIG5ld1RyZWUucm9vdCA9IHRoaXMucm9vdDtcbiAgICAgICAgbmV3VHJlZS5uZXh0SW5kZXggPSB0aGlzLm5leHRJbmRleDtcbiAgICAgICAgcmV0dXJuIG5ld1RyZWU7XG4gICAgfVxufVxuZXhwb3J0cy5JbmNyZW1lbnRhbFF1aW5UcmVlID0gSW5jcmVtZW50YWxRdWluVHJlZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1aW5UcmVlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maci-crypto/build/ts/quinTree.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/maci-crypto/build/ts/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/maci-crypto/build/ts/utils.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.genTreeProof = exports.genTreeCommitment = exports.calcDepthFromNumLeaves = void 0;\nconst hashing_1 = __webpack_require__(/*! ./hashing */ \"(ssr)/./node_modules/maci-crypto/build/ts/hashing.js\");\nconst quinTree_1 = __webpack_require__(/*! ./quinTree */ \"(ssr)/./node_modules/maci-crypto/build/ts/quinTree.js\");\n/**\n * Calculate the depth of a tree given the number of leaves\n * @param hashLength the hashing function param length\n * @param numLeaves how many leaves\n * @returns the depth\n */\nconst calcDepthFromNumLeaves = (hashLength, numLeaves) => {\n    let depth = 1;\n    let max = hashLength ** depth;\n    while (BigInt(max) < numLeaves) {\n        depth += 1;\n        max = hashLength ** depth;\n    }\n    return depth;\n};\nexports.calcDepthFromNumLeaves = calcDepthFromNumLeaves;\n/**\n * A helper function which hashes a list of results with a salt and returns the\n * hash.\n * @param leaves A list of values\n * @param salt A random salt\n * @param depth The tree depth\n * @returns The hash of the leaves and the salt, with the salt last\n */\nconst genTreeCommitment = (leaves, salt, depth) => {\n    const tree = new quinTree_1.IncrementalQuinTree(depth, 0n, 5, hashing_1.hash5);\n    leaves.forEach((leaf) => {\n        tree.insert(leaf);\n    });\n    return (0, hashing_1.hashLeftRight)(tree.root, salt);\n};\nexports.genTreeCommitment = genTreeCommitment;\n/**\n * A helper function to generate the tree proof for the value at the given index in the leaves\n * @param index The index of the value to generate the proof for\n * @param leaves A list of values\n * @param depth The tree depth\n * @returns The proof\n */\nconst genTreeProof = (index, leaves, depth) => {\n    const tree = new quinTree_1.IncrementalQuinTree(depth, 0n, 5, hashing_1.hash5);\n    leaves.forEach((leaf) => {\n        tree.insert(leaf);\n    });\n    const proof = tree.genProof(index);\n    return proof.pathElements;\n};\nexports.genTreeProof = genTreeProof;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFjaS1jcnlwdG8vYnVpbGQvdHMvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcseUJBQXlCLEdBQUcsOEJBQThCO0FBQ2pGLGtCQUFrQixtQkFBTyxDQUFDLHVFQUFXO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLHlFQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvbWFjaS1jcnlwdG8vYnVpbGQvdHMvdXRpbHMuanM/YjNkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2VuVHJlZVByb29mID0gZXhwb3J0cy5nZW5UcmVlQ29tbWl0bWVudCA9IGV4cG9ydHMuY2FsY0RlcHRoRnJvbU51bUxlYXZlcyA9IHZvaWQgMDtcbmNvbnN0IGhhc2hpbmdfMSA9IHJlcXVpcmUoXCIuL2hhc2hpbmdcIik7XG5jb25zdCBxdWluVHJlZV8xID0gcmVxdWlyZShcIi4vcXVpblRyZWVcIik7XG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgZGVwdGggb2YgYSB0cmVlIGdpdmVuIHRoZSBudW1iZXIgb2YgbGVhdmVzXG4gKiBAcGFyYW0gaGFzaExlbmd0aCB0aGUgaGFzaGluZyBmdW5jdGlvbiBwYXJhbSBsZW5ndGhcbiAqIEBwYXJhbSBudW1MZWF2ZXMgaG93IG1hbnkgbGVhdmVzXG4gKiBAcmV0dXJucyB0aGUgZGVwdGhcbiAqL1xuY29uc3QgY2FsY0RlcHRoRnJvbU51bUxlYXZlcyA9IChoYXNoTGVuZ3RoLCBudW1MZWF2ZXMpID0+IHtcbiAgICBsZXQgZGVwdGggPSAxO1xuICAgIGxldCBtYXggPSBoYXNoTGVuZ3RoICoqIGRlcHRoO1xuICAgIHdoaWxlIChCaWdJbnQobWF4KSA8IG51bUxlYXZlcykge1xuICAgICAgICBkZXB0aCArPSAxO1xuICAgICAgICBtYXggPSBoYXNoTGVuZ3RoICoqIGRlcHRoO1xuICAgIH1cbiAgICByZXR1cm4gZGVwdGg7XG59O1xuZXhwb3J0cy5jYWxjRGVwdGhGcm9tTnVtTGVhdmVzID0gY2FsY0RlcHRoRnJvbU51bUxlYXZlcztcbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gd2hpY2ggaGFzaGVzIGEgbGlzdCBvZiByZXN1bHRzIHdpdGggYSBzYWx0IGFuZCByZXR1cm5zIHRoZVxuICogaGFzaC5cbiAqIEBwYXJhbSBsZWF2ZXMgQSBsaXN0IG9mIHZhbHVlc1xuICogQHBhcmFtIHNhbHQgQSByYW5kb20gc2FsdFxuICogQHBhcmFtIGRlcHRoIFRoZSB0cmVlIGRlcHRoXG4gKiBAcmV0dXJucyBUaGUgaGFzaCBvZiB0aGUgbGVhdmVzIGFuZCB0aGUgc2FsdCwgd2l0aCB0aGUgc2FsdCBsYXN0XG4gKi9cbmNvbnN0IGdlblRyZWVDb21taXRtZW50ID0gKGxlYXZlcywgc2FsdCwgZGVwdGgpID0+IHtcbiAgICBjb25zdCB0cmVlID0gbmV3IHF1aW5UcmVlXzEuSW5jcmVtZW50YWxRdWluVHJlZShkZXB0aCwgMG4sIDUsIGhhc2hpbmdfMS5oYXNoNSk7XG4gICAgbGVhdmVzLmZvckVhY2goKGxlYWYpID0+IHtcbiAgICAgICAgdHJlZS5pbnNlcnQobGVhZik7XG4gICAgfSk7XG4gICAgcmV0dXJuICgwLCBoYXNoaW5nXzEuaGFzaExlZnRSaWdodCkodHJlZS5yb290LCBzYWx0KTtcbn07XG5leHBvcnRzLmdlblRyZWVDb21taXRtZW50ID0gZ2VuVHJlZUNvbW1pdG1lbnQ7XG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIHRoZSB0cmVlIHByb29mIGZvciB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIGluZGV4IGluIHRoZSBsZWF2ZXNcbiAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHZhbHVlIHRvIGdlbmVyYXRlIHRoZSBwcm9vZiBmb3JcbiAqIEBwYXJhbSBsZWF2ZXMgQSBsaXN0IG9mIHZhbHVlc1xuICogQHBhcmFtIGRlcHRoIFRoZSB0cmVlIGRlcHRoXG4gKiBAcmV0dXJucyBUaGUgcHJvb2ZcbiAqL1xuY29uc3QgZ2VuVHJlZVByb29mID0gKGluZGV4LCBsZWF2ZXMsIGRlcHRoKSA9PiB7XG4gICAgY29uc3QgdHJlZSA9IG5ldyBxdWluVHJlZV8xLkluY3JlbWVudGFsUXVpblRyZWUoZGVwdGgsIDBuLCA1LCBoYXNoaW5nXzEuaGFzaDUpO1xuICAgIGxlYXZlcy5mb3JFYWNoKChsZWFmKSA9PiB7XG4gICAgICAgIHRyZWUuaW5zZXJ0KGxlYWYpO1xuICAgIH0pO1xuICAgIGNvbnN0IHByb29mID0gdHJlZS5nZW5Qcm9vZihpbmRleCk7XG4gICAgcmV0dXJuIHByb29mLnBhdGhFbGVtZW50cztcbn07XG5leHBvcnRzLmdlblRyZWVQcm9vZiA9IGdlblRyZWVQcm9vZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/maci-crypto/build/ts/utils.js\n");

/***/ })

};
;